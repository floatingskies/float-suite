<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Inkling.web - Pro SVG Editor</title>
    
    <!-- Meta for PWA -->
    <meta name="theme-color" content="#FFDE59">
    <meta name="description" content="Professional Vector Graphics Editor in a Single File">

    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        /* =========================================
           NEO-BRUTALIST SYSTEM VARIABLES
           ========================================= */
        :root {
            --c-bg: #e0e0e0;
            --c-panel: #ffffff;
            --c-border: #000000;
            --c-text: #000000;
            
            --c-primary: #FFDE59;   /* Acid Yellow */
            --c-secondary: #FF90E8; /* Hot Pink */
            --c-accent: #23C9FF;    /* Cyan */
            --c-danger: #FF4D4D;
            
            --border-width: 3px;
            --shadow-hard: 4px 4px 0px var(--c-border);
            --shadow-active: 2px 2px 0px var(--c-border);
            
            --font-ui: 'Courier New', Courier, monospace;
            --sidebar-w: 260px;
            --prop-w: 240px;
            --header-h: 50px;
        }

        [data-theme="dark"] {
            --c-bg: #121212;
            --c-panel: #1e1e1e;
            --c-text: #ffffff;
            --c-border: #ffffff;
            --c-primary: #bfa300;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-user-select: none; }
        
        body {
            background-color: var(--c-bg);
            color: var(--c-text);
            font-family: var(--font-ui);
            font-size: 13px;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* =========================================
           UI COMPONENTS
           ========================================= */
        .btn {
            background: var(--c-panel);
            border: var(--border-width) solid var(--c-border);
            box-shadow: 2px 2px 0px var(--c-border);
            padding: 8px 12px;
            font-family: var(--font-ui);
            font-weight: 700;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.1s;
            display: flex; align-items: center; justify-content: center; gap: 6px;
        }
        .btn:hover { transform: translate(-1px, -1px); box-shadow: 3px 3px 0px var(--c-border); }
        .btn:active, .btn.active { transform: translate(2px, 2px); box-shadow: 0px 0px 0px var(--c-border); }
        
        .btn-primary { background: var(--c-primary); }
        .btn-danger { background: var(--c-danger); color: #fff; }
        .btn-icon { width: 36px; height: 36px; padding: 0; }
        .btn-sm { padding: 4px 8px; font-size: 11px; }
        .btn-group { display: flex; gap: 2px; }

        .panel {
            background: var(--c-panel);
            border: var(--border-width) solid var(--c-border);
            z-index: 10;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            background: var(--c-primary);
            border-bottom: var(--border-width) solid var(--c-border);
            padding: 8px 12px;
            font-weight: 900;
            text-transform: uppercase;
            display: flex; justify-content: space-between; align-items: center;
        }

        .form-group { margin-bottom: 10px; }
        .form-group label { display: block; margin-bottom: 4px; font-weight: bold; font-size: 11px; }
        input[type="color"] { width: 100%; height: 30px; border: 2px solid var(--c-border); cursor: pointer; padding: 0; }
        input[type="number"], input[type="text"] {
            width: 100%; border: 2px solid var(--c-border); padding: 4px;
            background: var(--c-bg); font-family: var(--font-ui); font-weight: bold;
        }

        /* =========================================
           LAYOUT
           ========================================= */
        header {
            height: var(--header-h);
            border-bottom: var(--border-width) solid var(--c-border);
            background: var(--c-primary);
            display: flex; align-items: center; justify-content: space-between; padding: 0 15px;
            z-index: 20;
        }

        .logo { font-size: 20px; font-weight: 900; letter-spacing: -1px; }

        #workspace {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* LEFT TOOLBAR */
        #toolbar {
            width: var(--sidebar-w);
            border-right: var(--border-width) solid var(--c-border);
            padding: 10px;
            gap: 8px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        /* CENTER CANVAS */
        #viewport {
            flex: 1;
            background-color: #999;
            /* Dot pattern */
            background-image: radial-gradient(#000 1px, transparent 1px);
            background-size: 20px 20px;
            position: relative;
            overflow: hidden;
            cursor: default;
        }
        
        /* The actual Artboard Container (Handles Zoom/Pan) */
        #artboard-container {
            width: 100%; height: 100%;
            position: absolute;
            top: 0; left: 0;
            transform-origin: 0 0;
            display: flex; align-items: center; justify-content: center;
        }

        /* The actual Artboard (Fixed size, scales visually) */
        #artboard {
            width: 800px; height: 600px;
            background: #fff;
            border: var(--border-width) solid var(--c-border);
            box-shadow: 10px 10px 0px rgba(0,0,0,0.5);
            position: relative;
            overflow: hidden; /* SVG clips to this */
            flex-shrink: 0;
        }
        
        svg { width: 100%; height: 100%; display: block; }

        /* Vector Elements Styling */
        .vector-element {
            cursor: pointer;
            vector-effect: non-scaling-stroke;
        }
        .vector-element:hover {
            opacity: 0.8;
            stroke-dasharray: 5,5; /* Neo-brutalist hover effect */
        }
        .vector-element.selected {
            stroke: var(--c-accent) !important;
            stroke-width: 2px !important;
            stroke-dasharray: none;
        }

        /* Selection Box (Overlay) */
        #selection-box {
            position: absolute;
            border: 2px dashed var(--c-accent);
            pointer-events: none;
            display: none;
            box-shadow: 0 0 0 9999px rgba(0,0,0,0.1); /* Dim background */
        }

        /* Temporary Text Input */
        #text-editor-overlay {
            position: absolute;
            background: transparent;
            border: 1px dashed var(--c-accent);
            color: #000;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 24px;
            padding: 0;
            margin: 0;
            outline: none;
            resize: none;
            overflow: hidden;
            display: none;
            z-index: 100;
        }

        /* RIGHT PROPERTIES */
        #properties {
            width: var(--prop-w);
            border-left: var(--border-width) solid var(--c-border);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* LAYERS LIST */
        #layers-list {
            flex: 1;
            overflow-y: auto;
            border-top: var(--border-width) solid var(--c-border);
            margin-top: 10px;
            padding-top: 5px;
        }
        .layer-item {
            padding: 6px;
            border-bottom: 1px solid #ccc;
            cursor: pointer;
            display: flex; align-items: center; gap: 8px;
        }
        .layer-item:hover { background: #eee; }
        .layer-item.active { background: var(--c-primary); font-weight: bold; }
        .layer-icon { width: 16px; text-align: center; }

        /* RESPONSIVE */
        @media (max-width: 900px) {
            #toolbar { position: absolute; height: auto; width: 100%; bottom: 0; left: 0; 
                        flex-direction: row; border-top: var(--border-width) solid var(--c-border); border-right: none; 
                        padding: 5px; z-index: 50; background: var(--c-panel); }
            #properties { display: none; } 
            #properties.mobile-active { display: flex; position: absolute; right: 0; height: 100%; z-index: 60; width: 80%; }
        }

        /* TOAST */
        .toast {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: var(--c-text); color: var(--c-bg);
            padding: 10px 20px; border: 2px solid var(--c-border);
            box-shadow: 4px 4px 0px var(--c-border);
            font-weight: bold; z-index: 1000;
            animation: popUp 0.3s ease-out;
        }
        @keyframes popUp { from {transform: translate(-50%, 100%);} to {transform: translate(-50%, 0);} }

        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex; align-items: center; justify-content: center;
            z-index: 2000;
        }
        .modal.hidden { display: none; }
        .modal-content {
            background: var(--c-panel); border: var(--border-width) solid var(--c-border);
            padding: 20px; width: 90%; max-width: 500px;
            box-shadow: 10px 10px 0px var(--c-border);
        }

        /* Zoom Controls Floating */
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: var(--c-panel);
            border: var(--border-width) solid var(--c-border);
            padding: 5px;
            display: flex;
            gap: 5px;
            box-shadow: 3px 3px 0px var(--c-border);
            z-index: 90;
        }

    </style>
</head>
<body>

    <!-- HEADER -->
    <header>
        <div class="logo"><i class="fas fa-shapes"></i> INKLING.WEB</div>
        <div style="display:flex; gap:5px;">
            <button class="btn btn-sm" id="btn-undo"><i class="fas fa-undo"></i></button>
            <button class="btn btn-sm" id="btn-redo"><i class="fas fa-redo"></i></button>
            <div style="width:2px; background:var(--c-border); margin:0 5px;"></div>
            <button class="btn btn-sm" id="btn-import-svg"><i class="fas fa-file-import"></i> Import SVG</button>
            <input type="file" id="file-input" accept=".svg" class="hidden">
            <button class="btn btn-sm btn-primary" id="btn-save-json"><i class="fas fa-save"></i> Save</button>
            <button class="btn btn-sm" id="btn-export-svg"><i class="fas fa-file-export"></i> SVG</button>
            <button class="btn btn-sm btn-danger" id="btn-clear"><i class="fas fa-trash"></i></button>
        </div>
    </header>

    <div id="workspace">
        
        <!-- LEFT TOOLBAR -->
        <nav class="panel" id="toolbar">
            <div class="panel-header">Tools</div>
            <button class="btn active" id="tool-select" title="Select & Move (V)"><i class="fas fa-mouse-pointer"></i> Select</button>
            <div style="height:2px; background:var(--c-border); margin: 5px 0;"></div>
            <button class="btn" id="tool-rect" title="Rectangle (R)"><i class="far fa-square"></i> Rect</button>
            <button class="btn" id="tool-circle" title="Circle (C)"><i class="far fa-circle"></i> Circle</button>
            <button class="btn" id="tool-line" title="Line (L)"><i class="fas fa-slash"></i> Line</button>
            <button class="btn" id="tool-pen" title="Freehand (P)"><i class="fas fa-pencil-alt"></i> Pen</button>
            <button class="btn" id="tool-text" title="Text (T)"><i class="fas fa-font"></i> Text</button>
            
            <div style="margin-top:auto; padding-top:10px;">
                 <button class="btn btn-sm" id="btn-theme"><i class="fas fa-moon"></i> Theme</button>
                 <div style="font-size:10px; opacity:0.6; margin-top:5px; text-align:center;">Hold SPACE to Pan</div>
            </div>
        </nav>

        <!-- CENTER VIEWPORT -->
        <main id="viewport">
            <div id="artboard-container">
                <div id="artboard">
                    <svg id="main-svg" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <!-- Define filters or patterns here if needed -->
                        </defs>
                        <g id="drawing-layer"></g>
                    </svg>
                    <!-- Selection Overlay Box -->
                    <div id="selection-box"></div>
                    <!-- Text Editor Overlay -->
                    <textarea id="text-editor-overlay"></textarea>
                </div>
            </div>

            <!-- Zoom Controls -->
            <div class="zoom-controls">
                <button class="btn btn-sm btn-icon" id="zoom-out"><i class="fas fa-minus"></i></button>
                <button class="btn btn-sm" id="zoom-reset" style="font-size:11px; width:50px;">100%</button>
                <button class="btn btn-sm btn-icon" id="zoom-in"><i class="fas fa-plus"></i></button>
            </div>
        </main>

        <!-- RIGHT PROPERTIES -->
        <aside class="panel" id="properties">
            <div class="panel-header">
                <span>Properties</span>
                <i class="fas fa-sliders-h"></i>
            </div>

            <div id="prop-content">
                <p style="color:#888; font-style:italic;">Select an object to edit.</p>
            </div>

            <div id="prop-controls" class="hidden">
                <div class="form-group">
                    <label>Fill Color</label>
                    <div class="flex" style="gap:5px; display:flex;">
                        <input type="color" id="inp-fill" value="#FFDE59">
                        <button class="btn btn-sm" id="btn-fill-none">None</button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Stroke Color</label>
                    <div class="flex" style="gap:5px; display:flex;">
                        <input type="color" id="inp-stroke" value="#000000">
                        <input type="number" id="inp-stroke-width" value="2" min="0" max="50" style="width:50px">
                    </div>
                </div>
                <div class="form-group">
                    <label>Opacity</label>
                    <input type="range" id="inp-opacity" min="0" max="1" step="0.1" value="1">
                </div>
                
                <div class="form-group">
                    <label>Alignment</label>
                    <div class="btn-group" style="display:flex; gap:2px; flex-wrap:wrap;">
                        <button class="btn btn-sm" id="btn-align-h" title="Align Horizontal Center"><i class="fas fa-arrows-alt-h"></i></button>
                        <button class="btn btn-sm" id="btn-align-v" title="Align Vertical Center"><i class="fas fa-arrows-alt-v"></i></button>
                    </div>
                </div>

                <div class="flex gap-5" style="margin-top:10px; display:flex; gap:5px;">
                    <button class="btn btn-sm" id="btn-up"><i class="fas fa-arrow-up"></i> Up</button>
                    <button class="btn btn-sm" id="btn-down"><i class="fas fa-arrow-down"></i> Down</button>
                    <button class="btn btn-sm btn-danger" id="btn-del-obj"><i class="fas fa-trash"></i></button>
                </div>
            </div>

            <div class="panel-header" style="margin-top:auto; font-size:12px; background:var(--c-secondary);">Layers</div>
            <div id="layers-list">
                <!-- Layer Items Injected Here -->
            </div>
        </aside>

    </div>

    <!-- MODALS -->
    <div class="modal hidden" id="about-modal">
        <div class="modal-content">
            <div style="font-size:24px; font-weight:900; margin-bottom:10px; border-bottom:3px solid #000; padding-bottom:10px;">INKLING(1)</div>
            <div style="font-family:'Courier New'; font-size:14px; line-height:1.5;">
                <b>NAME</b><br>
                Inkling - The SVG editor for the web<br><br>
                <b>SYNOPSIS</b><br>
                A ready for action SVG editor contained in a single HTML file.<br><br>
                <b>DESCRIPTION</b><br>
                Provides essential vector drawing capabilities including shapes, paths, 
                layers, styling, and SVG Import. Supports JSON serialization and raw SVG export.<br><br>
                <b>AUTHOR</b><br>
                Front-End Engineering AI<br>
                Version 2.0.0 Production
            </div>
            <div style="margin-top:20px; text-align:right;">
                <button class="btn btn-primary" onclick="document.getElementById('about-modal').classList.add('hidden')">Close</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * INKLING ENGINE v2.0
         * Single-file SVG Vector Editor
         */

        const Utils = {
            uid: () => 'id-' + Math.random().toString(36).substr(2, 9),
            toast: (msg) => {
                const t = document.createElement('div');
                t.className = 'toast'; t.innerText = msg;
                document.body.appendChild(t);
                setTimeout(() => t.remove(), 2000);
            },
            // Updated to handle Zoom/Pan transforms
            getMousePos: (evt, svg) => {
                const artboard = document.getElementById('artboard');
                const rect = artboard.getBoundingClientRect();
                
                // Calculate zoom from the computed style of the container
                const container = document.getElementById('artboard-container');
                const style = window.getComputedStyle(container);
                const matrix = new DOMMatrix(style.transform);
                const scale = matrix.a; // Assumes uniform scaling

                // Get position relative to the artboard, then un-scale
                return {
                    x: (evt.clientX - rect.left) / scale,
                    y: (evt.clientY - rect.top) / scale
                };
            }
        };

        class Inkling {
            constructor() {
                this.svg = document.getElementById('main-svg');
                this.layerGroup = document.getElementById('drawing-layer');
                this.selectedId = null;
                this.tool = 'select'; 
                this.isDrawing = false;
                this.isPanning = false;
                this.startPos = {x:0, y:0};
                this.currentShape = null;
                this.penPoints = [];
                
                // Viewport State
                this.zoom = 1;
                this.pan = {x: 0, y: 0};

                // History State
                this.historyStack = [];
                this.redoStack = [];
                this.maxHistory = 30;

                this.state = {
                    elements: [] 
                };

                this.init();
            }

            init() {
                this.bindToolbar();
                this.bindCanvasEvents();
                this.bindProperties();
                this.bindGlobal();
                this.saveHistory(); // Initial state
            }

            /* --- TOOLBAR LOGIC --- */
            setTool(toolName) {
                this.tool = toolName;
                document.querySelectorAll('#toolbar .btn').forEach(b => b.classList.remove('active'));
                document.getElementById(`tool-${toolName}`).classList.add('active');
                
                if(toolName !== 'select') this.deselect();
                
                const vp = document.getElementById('viewport');
                vp.style.cursor = toolName === 'select' ? 'default' : 'crosshair';
            }

            bindToolbar() {
                ['select', 'rect', 'circle', 'line', 'pen', 'text'].forEach(t => {
                    document.getElementById(`tool-${t}`).onclick = () => this.setTool(t);
                });

                document.getElementById('btn-clear').onclick = () => {
                    if(confirm('Delete all artwork?')) {
                        this.saveHistory();
                        this.layerGroup.innerHTML = '';
                        this.state.elements = [];
                        this.selectedId = null;
                        this.updatePropUI();
                        this.renderLayers();
                    }
                };
                
                document.getElementById('btn-theme').onclick = () => {
                    document.body.toggleAttribute('data-theme');
                };
            }

            /* --- CANVAS INTERACTION --- */
            bindCanvasEvents() {
                const svg = this.svg;
                
                svg.addEventListener('mousedown', (e) => this.onMouseDown(e));
                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                window.addEventListener('mouseup', (e) => this.onMouseUp(e));
                
                // Panning Logic
                const viewport = document.getElementById('viewport');
                viewport.addEventListener('mousedown', (e) => {
                    // Middle mouse or Spacebar+Click
                    if (e.button === 1 || (e.button === 0 && e.code === 'Space') || (e.button === 0 && this.isSpacePressed)) {
                        e.preventDefault();
                        this.isPanning = true;
                        this.startPos = { x: e.clientX, y: e.clientY };
                        viewport.style.cursor = 'grabbing';
                    }
                });

                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') { this.isSpacePressed = true; if(this.tool !== 'select') viewport.style.cursor = 'grab'; }
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); this.undo(); }
                    if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); this.redo(); }
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                            this.deleteSelected();
                        }
                    }
                });

                window.addEventListener('keyup', (e) => {
                    if (e.code === 'Space') { 
                        this.isSpacePressed = false; 
                        this.isPanning = false; 
                        if(this.tool !== 'select') viewport.style.cursor = 'crosshair';
                    }
                });

                // Zoom Controls
                document.getElementById('zoom-in').onclick = () => this.setZoom(this.zoom + 0.1);
                document.getElementById('zoom-out').onclick = () => this.setZoom(this.zoom - 0.1);
                document.getElementById('zoom-reset').onclick = () => this.setZoom(1);
                
                // Wheel Zoom
                viewport.addEventListener('wheel', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        const delta = -Math.sign(e.deltaY) * 0.1;
                        this.setZoom(this.zoom + delta);
                    }
                }, {passive: false});
            }

            setZoom(newZoom) {
                this.zoom = Math.max(0.2, Math.min(newZoom, 5)); // Clamp
                document.getElementById('zoom-reset').innerText = Math.round(this.zoom * 100) + '%';
                this.updateTransform();
            }

            updateTransform() {
                const container = document.getElementById('artboard-container');
                // Center roughly based on zoom logic could be complex, keeping it simple for now
                container.style.transform = `translate(${this.pan.x}px, ${this.pan.y}px) scale(${this.zoom})`;
            }

            onMouseDown(e) {
                if (e.target.closest('#toolbar') || e.target.closest('#properties') || this.isPanning) return;

                // Double click detection for text editing
                if (e.detail === 2 && e.target.tagName === 'text' && this.tool === 'select') {
                    this.editText(e.target);
                    return;
                }

                const pos = Utils.getMousePos(e, this.svg);
                this.isDrawing = true;
                this.startPos = pos;
                this.saveHistory(); // Save state before action

                if (this.tool === 'select') {
                    if (e.target.classList.contains('vector-element')) {
                        this.selectElement(e.target);
                    } else {
                        this.deselect();
                    }
                } else if (this.tool === 'text') {
                    this.createText(pos.x, pos.y);
                    this.isDrawing = false; 
                } else if (this.tool === 'pen') {
                    this.penPoints = [pos.x, pos.y];
                    this.currentShape = this.createSVGElement('path', {
                        d: `M ${pos.x} ${pos.y}`,
                        fill: 'none',
                        stroke: '#000',
                        'stroke-width': 2
                    });
                } else if (this.tool === 'rect') {
                    this.currentShape = this.createSVGElement('rect', {
                        x: pos.x, y: pos.y, width: 0, height: 0,
                        fill: '#FFDE59', stroke: '#000', 'stroke-width': 2
                    });
                } else if (this.tool === 'circle') {
                    this.currentShape = this.createSVGElement('circle', {
                        cx: pos.x, cy: pos.y, r: 0,
                        fill: '#23C9FF', stroke: '#000', 'stroke-width': 2
                    });
                } else if (this.tool === 'line') {
                    this.currentShape = this.createSVGElement('line', {
                        x1: pos.x, y1: pos.y, x2: pos.x, y2: pos.y,
                        stroke: '#000', 'stroke-width': 2
                    });
                }
            }

            onMouseMove(e) {
                // Handle Panning
                if (this.isPanning) {
                    const dx = e.clientX - this.startPos.x;
                    const dy = e.clientY - this.startPos.y;
                    this.pan.x += dx;
                    this.pan.y += dy;
                    this.startPos = { x: e.clientX, y: e.clientY };
                    this.updateTransform();
                    return;
                }

                if (!this.isDrawing || !this.currentShape) return;
                
                // For move tool, handle dragging logic
                if (this.tool === 'select' && this.selectedId) {
                    const el = document.getElementById(this.selectedId);
                    if(el) {
                        const pos = Utils.getMousePos(e, this.svg);
                        const dx = pos.x - this.startPos.x;
                        const dy = pos.y - this.startPos.y;
                        
                        const transforms = el.transform.baseVal;
                        if (transforms.length === 0 || transforms.getItem(0).type !== SVGTransform.SVG_TRANSFORM_TRANSLATE) {
                            const translate = this.svg.createSVGTransform();
                            translate.setTranslate(0, 0);
                            el.transform.baseVal.insertItemBefore(translate, 0);
                        }
                        const trans = transforms.getItem(0);
                        trans.setTranslate(trans.matrix.e + dx, trans.matrix.f + dy);
                        
                        this.startPos = pos; 
                    }
                    return;
                }

                // Creation Logic
                const pos = Utils.getMousePos(e, this.svg);

                if (this.tool === 'pen') {
                    this.penPoints.push(pos.x, pos.y);
                    this.currentShape.setAttribute('d', `M ${this.penPoints.join(' L ')}`);
                } else if (this.tool === 'rect') {
                    const w = pos.x - this.startPos.x;
                    const h = pos.y - this.startPos.y;
                    this.currentShape.setAttribute('x', w < 0 ? pos.x : this.startPos.x);
                    this.currentShape.setAttribute('y', h < 0 ? pos.y : this.startPos.y);
                    this.currentShape.setAttribute('width', Math.abs(w));
                    this.currentShape.setAttribute('height', Math.abs(h));
                } else if (this.tool === 'circle') {
                    const r = Math.sqrt(Math.pow(pos.x - this.startPos.x, 2) + Math.pow(pos.y - this.startPos.y, 2));
                    this.currentShape.setAttribute('r', r);
                } else if (this.tool === 'line') {
                    this.currentShape.setAttribute('x2', pos.x);
                    this.currentShape.setAttribute('y2', pos.y);
                }
            }

            onMouseUp(e) {
                if (this.isPanning) {
                    this.isPanning = false;
                    document.getElementById('viewport').style.cursor = this.tool === 'select' ? 'default' : 'crosshair';
                    return;
                }

                if (!this.isDrawing) return;
                this.isDrawing = false;
                
                if (this.currentShape) {
                    this.currentShape.classList.add('vector-element');
                    this.currentShape.id = this.currentShape.id || Utils.uid();
                    
                    const type = this.currentShape.tagName;
                    const icon = type === 'rect' ? 'square' : type === 'circle' ? 'circle' : type === 'path' ? 'pencil-alt' : type === 'line' ? 'slash' : 'font';
                    
                    this.state.elements.push({
                        id: this.currentShape.id,
                        type: type,
                        icon: icon
                    });

                    this.selectElement(this.currentShape);
                    this.renderLayers();
                    this.setTool('select'); 
                }
                
                this.currentShape = null;
                this.penPoints = [];
            }

            createSVGElement(tag, attrs) {
                const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
                for (let k in attrs) el.setAttribute(k, attrs[k]);
                this.layerGroup.appendChild(el);
                return el;
            }

            /* --- TEXT EDITING --- */
            createText(x, y) {
                // Create a dummy text first
                const el = this.createSVGElement('text', {
                    x: x, y: y,
                    fill: '#000', 'font-family': 'Courier New', 'font-weight': 'bold', 'font-size': '24px'
                });
                el.textContent = "Text";
                
                this.state.elements.push({
                    id: el.id, type: 'text', icon: 'font'
                });
                this.renderLayers();
                this.selectElement(el);
                this.editText(el); // Immediately edit
                this.setTool('select');
            }

            editText(el) {
                const bbox = el.getBoundingClientRect();
                const artboard = document.getElementById('artboard');
                const artRect = artboard.getBoundingClientRect();
                
                const overlay = document.getElementById('text-editor-overlay');
                
                // Position overlay
                overlay.style.display = 'block';
                overlay.style.left = (bbox.left - artRect.left) + 'px';
                overlay.style.top = (bbox.top - artRect.top - 5) + 'px'; // slight offset for baseline
                overlay.style.width = Math.max(bbox.width + 20, 100) + 'px';
                overlay.style.height = Math.max(bbox.height + 10, 30) + 'px';
                
                // Copy styles
                const style = window.getComputedStyle(el);
                overlay.style.fontSize = style.fontSize;
                overlay.style.fontFamily = style.fontFamily;
                overlay.style.color = style.fill;
                
                overlay.value = el.textContent;
                overlay.focus();

                const finishEdit = () => {
                    el.textContent = overlay.value;
                    overlay.style.display = 'none';
                    overlay.value = '';
                    overlay.removeEventListener('blur', finishEdit);
                    overlay.removeEventListener('keydown', keyHandler);
                };

                const keyHandler = (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        finishEdit();
                    }
                };

                overlay.addEventListener('blur', finishEdit);
                overlay.addEventListener('keydown', keyHandler);
            }

            /* --- IMPORT SVG --- */
            importSVG() {
                const input = document.getElementById('file-input');
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        this.saveHistory();
                        try {
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(ev.target.result, "image/svg+xml");
                            const svgChildren = doc.documentElement.children;
                            
                            // Unwrap and import children
                            Array.from(svgChildren).forEach(child => {
                                if (child.tagName !== 'defs') { // Skip definitions for simplicity or handle them
                                    const imported = document.importNode(child, true);
                                    // Clean transforms or IDs if necessary
                                    imported.id = Utils.uid();
                                    imported.classList.add('vector-element');
                                    this.layerGroup.appendChild(imported);
                                    
                                    // Add to state
                                    const type = imported.tagName;
                                    const icon = type === 'rect' ? 'square' : type === 'circle' ? 'circle' : type === 'path' ? 'pencil-alt' : 'square';
                                    this.state.elements.push({
                                        id: imported.id,
                                        type: type,
                                        icon: icon
                                    });
                                }
                            });
                            this.renderLayers();
                            Utils.toast('SVG Imported');
                        } catch(err) {
                            Utils.toast('Import Failed', 'error');
                            console.error(err);
                        }
                        input.value = ''; // Reset input
                    };
                    reader.readAsText(file);
                };
                input.click();
            }

            /* --- SELECTION & PROPERTIES --- */
            selectElement(el) {
                if (this.selectedId) {
                    const prev = document.getElementById(this.selectedId);
                    if (prev) prev.classList.remove('selected');
                }
                
                this.selectedId = el.id;
                el.classList.add('selected');
                this.updatePropUI(el);
                this.renderLayers();
            }

            deselect() {
                if (this.selectedId) {
                    const prev = document.getElementById(this.selectedId);
                    if (prev) prev.classList.remove('selected');
                }
                this.selectedId = null;
                this.updatePropUI(null);
                this.renderLayers();
            }

            deleteSelected() {
                if (!this.selectedId) return;
                this.saveHistory();
                const el = document.getElementById(this.selectedId);
                if (el) el.remove();
                
                this.state.elements = this.state.elements.filter(i => i.id !== this.selectedId);
                this.selectedId = null;
                this.updatePropUI(null);
                this.renderLayers();
                Utils.toast('Object Deleted');
            }

            alignElements(axis) {
                if (!this.selectedId) return;
                const el = document.getElementById(this.selectedId);
                if(!el) return;
                
                this.saveHistory();
                
                // We are aligning to the Artboard center (800x600)
                const centerX = 400;
                const centerY = 300;
                
                const bbox = el.getBBox();
                
                // Calculate translation to center
                const dx = centerX - (bbox.x + bbox.width / 2);
                const dy = centerY - (bbox.y + bbox.height / 2);
                
                const transforms = el.transform.baseVal;
                const translate = this.svg.createSVGTransform();
                translate.setTranslate(dx, dy);
                el.transform.baseVal.insertItemBefore(translate, 0);
            }

            bindProperties() {
                const updateAttr = (attr, val) => {
                    if (!this.selectedId) return;
                    const el = document.getElementById(this.selectedId);
                    if(el) {
                        // For transform-based moves, we don't overwrite attributes, but for fill/stroke we do
                        // Note: modifying an attribute should probably trigger history save? 
                        // For now, let's rely on MouseUp/Major actions for history to avoid spam.
                        el.setAttribute(attr, val);
                    }
                };

                document.getElementById('inp-fill').addEventListener('input', (e) => updateAttr('fill', e.target.value));
                document.getElementById('btn-fill-none').addEventListener('click', () => updateAttr('fill', 'none'));
                
                document.getElementById('inp-stroke').addEventListener('input', (e) => updateAttr('stroke', e.target.value));
                document.getElementById('inp-stroke-width').addEventListener('input', (e) => updateAttr('stroke-width', e.target.value));
                document.getElementById('inp-opacity').addEventListener('input', (e) => updateAttr('opacity', e.target.value));

                // Layers
                document.getElementById('btn-up').onclick = () => {
                    this.saveHistory(); this.moveLayer('up');
                };
                document.getElementById('btn-down').onclick = () => {
                    this.saveHistory(); this.moveLayer('down');
                };
                document.getElementById('btn-del-obj').onclick = () => this.deleteSelected();

                // Alignment
                document.getElementById('btn-align-h').onclick = () => this.alignElements('h');
                document.getElementById('btn-align-v').onclick = () => this.alignElements('v');
            }

            updatePropUI(el) {
                const content = document.getElementById('prop-content');
                const controls = document.getElementById('prop-controls');

                if (!el) {
                    content.classList.remove('hidden');
                    controls.classList.add('hidden');
                    return;
                }

                content.classList.add('hidden');
                controls.classList.remove('hidden');

                document.getElementById('inp-fill').value = this.rgbToHex(el.getAttribute('fill') || '#000000');
                document.getElementById('inp-stroke').value = this.rgbToHex(el.getAttribute('stroke') || '#000000');
                document.getElementById('inp-stroke-width').value = el.getAttribute('stroke-width') || 1;
                document.getElementById('inp-opacity').value = el.getAttribute('opacity') || 1;
            }

            rgbToHex(col) {
                if(!col || col === 'none') return '#ffffff';
                if(col.startsWith('#')) return col;
                const ctx = document.createElement('canvas').getContext('2d');
                ctx.fillStyle = col;
                return ctx.fillStyle; 
            }

            moveLayer(dir) {
                if(!this.selectedId) return;
                const el = document.getElementById(this.selectedId);
                const parent = el.parentNode;
                
                if(dir === 'up') {
                    const next = el.nextElementSibling;
                    if(next) parent.insertBefore(next, el); 
                } else {
                    const prev = el.previousElementSibling;
                    if(prev) parent.insertBefore(el, prev);
                }
                this.renderLayers();
            }

            renderLayers() {
                const list = document.getElementById('layers-list');
                list.innerHTML = '';
                
                [...this.state.elements].reverse().forEach(item => {
                    // Verify element still exists
                    const el = document.getElementById(item.id);
                    if(!el) return;

                    const div = document.createElement('div');
                    div.className = `layer-item ${item.id === this.selectedId ? 'active' : ''}`;
                    div.innerHTML = `<i class="fas fa-${item.icon} layer-icon"></i> ${item.type.toUpperCase()} <small>(${item.id.substr(3,4)})</small>`;
                    div.onclick = () => {
                        const el = document.getElementById(item.id);
                        if(el) this.selectElement(el);
                    };
                    list.appendChild(div);
                });
            }

            /* --- HISTORY SYSTEM --- */
            saveHistory() {
                // Serialize current state
                const html = this.layerGroup.innerHTML;
                
                // Avoid duplicate states (basic check)
                if (this.historyStack.length > 0 && this.historyStack[this.historyStack.length - 1] === html) {
                    return;
                }

                this.historyStack.push(html);
                if (this.historyStack.length > this.maxHistory) this.historyStack.shift();
                this.redoStack = []; // Clear redo on new action
                this.updateHistoryUI();
            }

            undo() {
                if (this.historyStack.length <= 1) return; // Keep initial empty state
                
                this.redoStack.push(this.historyStack.pop());
                const prevHtml = this.historyStack[this.historyStack.length - 1];
                this.layerGroup.innerHTML = prevHtml;
                
                // Re-attach events/listeners if needed (none currently rely on JS refs)
                // Just update IDs mapping
                this.rebuildStateFromDOM();
                this.updateHistoryUI();
            }

            redo() {
                if (this.redoStack.length === 0) return;
                
                const nextHtml = this.redoStack.pop();
                this.historyStack.push(nextHtml);
                this.layerGroup.innerHTML = nextHtml;
                
                this.rebuildStateFromDOM();
                this.updateHistoryUI();
            }

            rebuildStateFromDOM() {
                this.selectedId = null;
                this.state.elements = [];
                const children = Array.from(this.layerGroup.children);
                children.forEach(child => {
                    const id = child.id || Utils.uid();
                    child.id = id;
                    child.classList.add('vector-element'); // Ensure class is present
                    
                    const type = child.tagName;
                    const icon = type === 'rect' ? 'square' : type === 'circle' ? 'circle' : type === 'path' ? 'pencil-alt' : type === 'line' ? 'slash' : 'font';
                    
                    this.state.elements.push({ id, type, icon });
                });
                this.renderLayers();
                this.updatePropUI(null);
            }

            updateHistoryUI() {
                document.getElementById('btn-undo').style.opacity = this.historyStack.length > 1 ? '1' : '0.5';
                document.getElementById('btn-redo').style.opacity = this.redoStack.length > 0 ? '1' : '0.5';
            }

            /* --- SAVE / EXPORT / GLOBAL --- */
            bindGlobal() {
                // About Modal
                const aboutModal = document.getElementById('about-modal');
                document.getElementById('btn-about').onclick = () => aboutModal.classList.remove('hidden');

                // Import
                document.getElementById('btn-import-svg').onclick = () => this.importSVG();

                // Export JSON
                document.getElementById('btn-save-json').onclick = () => {
                    const serializer = new XMLSerializer();
                    const svgString = serializer.serializeToString(this.svg);
                    const data = {
                        version: 2.0,
                        zoom: this.zoom,
                        pan: this.pan,
                        svg: svgString,
                        elements: this.state.elements
                    };
                    const blob = new Blob([JSON.stringify(data)], {type: 'application/json'});
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = 'inkling-project.json';
                    a.click();
                    Utils.toast('Project Saved (JSON)');
                };

                // Export SVG
                document.getElementById('btn-export-svg').onclick = () => {
                    const serializer = new XMLSerializer();
                    let source = serializer.serializeToString(this.svg);
                    if(!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)){
                        source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
                    }
                    const blob = new Blob([source], {type: "image/svg+xml;charset=utf-8"});
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = "artwork.svg";
                    a.click();
                    Utils.toast('Exported SVG');
                };
            }

            saveState() {
                // Autosave to LocalStorage
                const serializer = new XMLSerializer();
                const svgString = serializer.serializeToString(this.svg);
                localStorage.setItem('inkling-autosave', JSON.stringify({
                    zoom: this.zoom,
                    pan: this.pan,
                    svg: svgString,
                    elements: this.state.elements
                }));
            }

            loadState() {
                const raw = localStorage.getItem('inkling-autosave');
                if(raw) {
                    try {
                        const data = JSON.parse(raw);
                        
                        // Restore Viewport
                        if (data.zoom) this.setZoom(data.zoom);
                        if (data.pan) {
                            this.pan = data.pan;
                            this.updateTransform();
                        }

                        // Restore Content
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(data.svg, "image/svg+xml");
                        this.svg.innerHTML = doc.documentElement.innerHTML;
                        this.state.elements = data.elements || [];
                        this.rebuildStateFromDOM(); // This calls renderLayers
                        
                    } catch(e) {
                        console.error("Autoload failed", e);
                    }
                }
            }
        }

        // Initialize App
        document.addEventListener('DOMContentLoaded', () => {
            window.App = new Inkling();
            window.App.loadState();
            
            // Autosave interval
            setInterval(() => window.App.saveState(), 5000);
        });

    </script>
</body>
</html>
