<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Inkling.Web - SVG Editor</title>
    
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Archivo+Black&display=swap" rel="stylesheet">

    <style>
        :root {
            --c-bg: #f0f0f0; /* Light concrete */
            --c-panel: #ffffff;
            --c-border: #000000; 
            --c-text: #000000;
            
            --c-primary: #000000;
            --c-accent: #3b82f6; /* Pure Blue for selection */
            --c-hover: #f4f4f4;
            
            --border-width: 3px;
            --shadow-hard: 4px 4px 0px 0px #000000;
            --shadow-active: 2px 2px 0px 0px #000000;
            --shadow-panel: 6px 6px 0px 0px #000000;
            
            --font-ui: 'Space Mono', monospace;
            --font-head: 'Archivo Black', sans-serif;
            
            --sidebar-w: 300px;
            --header-h: 50px;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; outline: none; }
        
        body {
            background-color: var(--c-bg);
            /* Graph paper pattern */
            background-image: radial-gradient(#000 1px, transparent 1px);
            background-size: 20px 20px;
            
            color: var(--c-text);
            font-family: var(--font-ui);
            font-size: 12px;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            user-select: none;
        }

        /* BRUTALIST BUTTONS */
        .btn {
            background: var(--c-panel);
            border: var(--border-width) solid var(--c-border);
            color: var(--c-text);
            padding: 8px 12px;
            font-family: var(--font-ui);
            font-weight: 700;
            text-transform: uppercase;
            cursor: pointer;
            display: inline-flex; align-items: center; justify-content: center; gap: 8px;
            font-size: 11px;
            transition: all 0.1s;
            box-shadow: 2px 2px 0px 0px #000;
        }
        .btn:hover {
            transform: translate(-1px, -1px);
            box-shadow: 4px 4px 0px 0px #000;
            background: #fff;
        }
        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: 0px 0px 0px 0px #000;
        }
        .btn.active {
            background: var(--c-accent);
            color: #fff;
            border-color: #000;
            box-shadow: 2px 2px 0px 0px #000;
        }
        .btn-sm { padding: 4px 8px; font-size: 10px; }
        .btn-icon { width: 40px; padding: 0; font-size: 14px; justify-content: center; }

        /* PANELS */
        .panel {
            background: var(--c-panel);
            border-right: var(--border-width) solid var(--c-border);
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        .panel-header {
            background: #000;
            color: #fff;
            border-bottom: var(--border-width) solid var(--c-border);
            padding: 8px 15px;
            font-family: var(--font-head);
            font-size: 14px;
            letter-spacing: 1px;
            display: flex; justify-content: space-between; align-items: center;
            text-transform: uppercase;
        }

        /* INPUTS */
        input[type="text"], input[type="number"], select {
            width: 100%; 
            border: 2px solid #000; 
            padding: 6px 8px;
            background: #fff; 
            color: #000; 
            font-family: var(--font-ui); 
            font-weight: bold;
        }
        input[type="color"] {
            width: 100%; height: 35px; 
            border: 2px solid #000; 
            padding: 0; background: none; cursor: pointer; 
        }
        input[type="range"] {
            width: 100%; 
            accent-color: #000; 
            cursor: pointer; 
            height: 4px;
            background: #ddd;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px; width: 20px;
            background: #000;
            border: 2px solid #fff;
            cursor: pointer;
            box-shadow: 2px 2px 0 0 #000;
        }

        header {
            height: var(--header-h);
            border-bottom: var(--border-width) solid var(--c-border);
            background: var(--c-panel);
            display: flex; align-items: center; justify-content: space-between; padding: 0 20px;
            z-index: 100;
            box-shadow: 0 4px 0 0 #000;
        }
        .logo { 
            font-family: var(--font-head); 
            font-size: 20px; 
            text-transform: uppercase; 
            background: #000; 
            color: #fff; 
            padding: 2px 8px;
            transform: rotate(-1deg);
        }

        #workspace { flex: 1; display: flex; overflow: hidden; position: relative; }

        #toolbar {
            width: 60px;
            border-right: var(--border-width) solid var(--c-border);
            padding: 15px 0;
            gap: 15px;
            display: flex; flex-direction: column;
            align-items: center;
            background: var(--c-panel);
        }

        #viewport {
            flex: 1;
            background-color: #fff;
            position: relative;
            overflow: hidden;
            display: flex; align-items: center; justify-content: center;
        }
        
        #artboard-container {
            width: 100%; height: 100%;
            position: relative;
            display: flex; align-items: center; justify-content: center;
            /* Shadow behind artboard */
        }

        #artboard {
            width: 800px; height: 600px;
            background: #fff;
            box-shadow: var(--shadow-panel);
            position: relative;
            overflow: visible; 
            flex-shrink: 0;
            border: var(--border-width) solid #000;
        }
        
        svg { width: 100%; height: 100%; display: block; overflow: visible; }

        /* ELEMENTS */
        .vector-element { cursor: pointer; vector-effect: non-scaling-stroke; }
        .vector-element:hover { stroke: var(--c-accent); stroke-width: 2px; stroke-dasharray: 5,5; }
        .vector-element.selected { 
            stroke: var(--c-accent) !important; 
            stroke-width: 3px !important; 
            stroke-dasharray: 5,3; 
            animation: dash 1s linear infinite;
            paint-order: stroke fill;
        }
        /* State when editing color: remove the selection highlight to see the real color */
        .vector-element.editing-color { 
            stroke: inherit !important; 
            stroke-width: inherit !important; 
            stroke-dasharray: none !important; 
            animation: none !important;
        }
        
        @keyframes dash { to { stroke-dashoffset: 16; } }

        /* NODE EDITOR */
        #node-editor-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 1000; overflow: visible;
        }
        #node-gizmo-svg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; overflow: visible;
        }

        .gizmo-line { stroke: #000; stroke-width: 2px; opacity: 0.5; }
        .gizmo-handle { fill: #fff; stroke: #000; stroke-width: 2px; cursor: pointer; pointer-events: all; }
        .gizmo-handle:hover { fill: var(--c-accent); stroke: #000; }
        
        .node-anchor { fill: #000; stroke: #fff; stroke-width: 2px; cursor: move; pointer-events: all; }
        .node-anchor.selected { fill: var(--c-accent); stroke: #fff; stroke-width: 3px; }

        /* HOVER DELETE BUTTON */
        #hover-delete-btn {
            position: absolute;
            width: 24px; height: 24px;
            background: #ff4d4d;
            color: #fff;
            border: 2px solid #000;
            display: none; /* Flex when shown */
            align-items: center; justify-content: center;
            font-weight: bold;
            cursor: pointer;
            z-index: 500;
            box-shadow: 2px 2px 0 0 #000;
            font-family: var(--font-head);
            font-size: 14px;
        }
        #hover-delete-btn:hover {
            background: #000;
            color: #ff4d4d;
            transform: scale(1.1);
        }

        /* PROPERTIES */
        #properties {
            width: var(--sidebar-w);
            border-left: var(--border-width) solid var(--c-border);
            display: flex; flex-direction: column;
            background: var(--c-panel);
        }
        .prop-group { padding: 15px; border-bottom: 3px solid #000; }
        .prop-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; gap: 10px; }
        .prop-label { font-size: 10px; font-weight: bold; min-width: 40px; }
        .section-title { 
            font-family: var(--font-head); 
            font-size: 12px; 
            text-transform: uppercase; 
            margin-bottom: 10px; 
            display: block; 
            border-bottom: 2px solid #000;
            padding-bottom: 5px;
        }

        /* LAYERS */
        #layers-list { flex: 1; overflow-y: auto; padding: 0; background: #fff; }
        .layer-item {
            padding: 10px 15px;
            border-bottom: 2px solid #000;
            cursor: pointer;
            display: flex; align-items: center; gap: 10px;
            font-size: 11px;
            font-weight: bold;
            background: #fff;
        }
        .layer-item:hover { background: #f0f0f0; }
        .layer-item.active { background: var(--c-accent); color: #fff; }
        .layer-controls { margin-left: auto; display: flex; gap: 8px; }
        .layer-btn { cursor: pointer; color: inherit; }

        /* TOAST */
        .toast {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(20px);
            background: #000; color: #fff;
            padding: 10px 20px; 
            font-family: var(--font-head); font-size: 14px;
            text-transform: uppercase;
            box-shadow: 4px 4px 0 0 var(--c-accent);
            opacity: 0; transition: all 0.2s; pointer-events: none; z-index: 2000;
            border: 2px solid #fff;
        }
        .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

    </style>
</head>
<body data-theme="brutalist">

    <header>
        <div class="logo">INKLING<strong style="color:var(--c-accent)">.WEB</strong></div>
        <div style="display:flex; gap:10px;">
            <button class="btn" id="btn-undo"><i class="fas fa-undo"></i> Undo</button>
            <button class="btn" id="btn-redo"><i class="fas fa-redo"></i> Redo</button>
            <button class="btn" id="btn-export" style="background:var(--c-accent); color:#fff;"><i class="fas fa-file-export"></i> SVG</button>
        </div>
    </header>

    <div id="workspace">
        <nav class="panel" id="toolbar">
            <button class="btn btn-icon active" id="tool-select" title="Select (V)"><i class="fas fa-mouse-pointer"></i></button>
            <button class="btn btn-icon" id="tool-node" title="Node Tool (N) - Edit Paths"><i class="fas fa-bezier-curve"></i></button>
            <div style="width:60%; height:3px; background:#000; margin:4px 0;"></div>
            <button class="btn btn-icon" id="tool-rect" title="Rect (R)"><i class="far fa-square"></i></button>
            <button class="btn btn-icon" id="tool-circle" title="Circle (C)"><i class="far fa-circle"></i></button>
            <button class="btn btn-icon" id="tool-pen" title="Pen Tool (P) - Click to add point, Drag to curve, Enter to finish"><i class="fas fa-pen-nib"></i></button>
        </nav>

        <main id="viewport">
            <div id="artboard-container">
                <div id="artboard">
                    <svg id="main-svg" viewBox="0 0 800 600" xmlns="http://www.w3.org/2000/svg">
                        <defs></defs>
                        <g id="drawing-layer"></g>
                    </svg>
                    <svg id="node-gizmo-svg" viewBox="0 0 800 600" style="position: absolute; top:0; left:0; width:100%; height:100%;"></svg>
                    <!-- Floating Delete Button -->
                    <div id="hover-delete-btn">X</div>
                </div>
            </div>
        </main>

        <aside class="panel" id="properties">
            <div class="panel-header">PROPERTIES</div>
            
            <div id="selection-props" style="display:none;">
                <!-- Radius Control (Only for Rects) -->
                <div id="radius-group" class="prop-group" style="display:none;">
                    <span class="section-title" style="color:var(--c-accent);">CORNER RADIUS</span>
                    <div class="prop-row">
                        <input type="range" id="inp-radius-range" min="0" max="100" step="1">
                        <input type="number" id="inp-radius-num" min="0" style="width:60px;">
                    </div>
                </div>

                <div class="prop-group">
                    <span class="section-title">GEOMETRY</span>
                    <div class="prop-row">
                        <span class="prop-label">X</span> <input type="number" id="inp-x">
                        <span class="prop-label">Y</span> <input type="number" id="inp-y">
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">W</span> <input type="number" id="inp-w">
                        <span class="prop-label">H</span> <input type="number" id="inp-h">
                    </div>
                </div>

                <div class="prop-group">
                    <span class="section-title">STYLE</span>
                    <div class="prop-row">
                        <span class="prop-label">Fill</span> <input type="color" id="inp-fill">
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">Stroke</span> 
                        <div style="display:flex; gap:5px; flex:1;">
                            <input type="color" id="inp-stroke">
                            <!-- Fixed ID for JS access -->
                            <input type="number" id="inp-stroke-width" placeholder="px" style="width:50px;">
                        </div>
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">Opacity</span> <input type="range" id="inp-opacity" min="0" max="1" step="0.1">
                    </div>
                </div>

                <div class="prop-group">
                    <span class="section-title">ACTIONS</span>
                    <button class="btn btn-sm" id="btn-topath" style="width:100%; margin-bottom:10px; border-style:dashed;">
                        <i class="fas fa-vector-square"></i> Convert to Path
                    </button>
                    <div style="display:flex; gap:5px;">
                        <button class="btn btn-sm" id="btn-dup" style="flex:1;"><i class="fas fa-copy"></i></button>
                        <button class="btn btn-sm" id="btn-del" style="flex:1; background:#000; color:#fff;"><i class="fas fa-trash"></i></button>
                    </div>
                </div>
            </div>
            
            <div class="panel-header">LAYERS</div>
            <div id="layers-list"></div>
        </aside>
    </div>

    <div class="toast" id="toast">Action</div>

    <script>
        const Utils = {
            uid: () => 'el_' + Math.random().toString(36).substr(2, 6),
            toast: (msg) => {
                const t = document.getElementById('toast');
                t.innerText = msg; t.classList.add('show');
                clearTimeout(t.timer);
                t.timer = setTimeout(() => t.classList.remove('show'), 2000);
            },
            getMousePos: (e) => {
                const artboard = document.getElementById('artboard');
                const rect = artboard.getBoundingClientRect();
                const scaleX = 800 / rect.width;
                const scaleY = 600 / rect.height;

                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            },
            createSVG: (tag, attrs) => {
                const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
                for (let k in attrs) el.setAttribute(k, attrs[k]);
                return el;
            }
        };

        const PathUtils = {
            shapeToPath: (el) => {
                const tag = el.tagName;
                let d = "";
                if (tag === 'rect') {
                    const x = parseFloat(el.getAttribute('x'));
                    const y = parseFloat(el.getAttribute('y'));
                    const w = parseFloat(el.getAttribute('width'));
                    const h = parseFloat(el.getAttribute('height'));
                    d = `M ${x} ${y} L ${x+w} ${y} L ${x+w} ${y+h} L ${x} ${y+h} Z`;
                } else if (tag === 'circle') {
                    const cx = parseFloat(el.getAttribute('cx'));
                    const cy = parseFloat(el.getAttribute('cy'));
                    const r = parseFloat(el.getAttribute('r'));
                    const k = 0.5522847498;
                    d = `M ${cx-r} ${cy} 
                        C ${cx-r} ${cy-r*k} ${cx-r*k} ${cy-r} ${cx} ${cy-r} 
                        C ${cx+r*k} ${cy-r} ${cx+r} ${cy-r*k} ${cx+r} ${cy} 
                        C ${cx+r} ${cy+r*k} ${cx+r*k} ${cy+r} ${cx} ${cy+r} 
                        C ${cx-r*k} ${cy+r} ${cx-r} ${cy+r*k} ${cx-r} ${cy} Z`;
                } else if (tag === 'path') return el.getAttribute('d');
                return d;
            },
            parsePath: (d) => {
                const points = [];
                const pathCmds = d.match(/[a-zA-Z][^a-zA-Z]*/g) || [];
                let lastX = 0, lastY = 0;
                
                pathCmds.forEach(cmdStr => {
                    const type = cmdStr[0];
                    const args = cmdStr.slice(1).trim().split(/[\s,]+/).map(Number);
                    
                    if(type === 'M') {
                        points.push({ x: args[0], y: args[1], type: 'anchor', hIn: null, hOut: null });
                        lastX = args[0]; lastY = args[1];
                    } else if(type === 'L') {
                        points.push({ x: args[0], y: args[1], type: 'anchor', hIn: null, hOut: null });
                        lastX = args[0]; lastY = args[1];
                    } else if(type === 'C') {
                        const prev = points[points.length-1];
                        if(prev) { prev.hOut = { x: args[0], y: args[1] }; }
                        points.push({ 
                            x: args[4], y: args[5], type: 'anchor', 
                            hIn: { x: args[2], y: args[3] }, 
                            hOut: null 
                        });
                        lastX = args[4]; lastY = args[5];
                    }
                });
                return points;
            },
            generatePathFromPoints: (points) => {
                if(points.length === 0) return "";
                let d = `M ${points[0].x} ${points[0].y} `;
                for(let i=1; i<points.length; i++) {
                    const p = points[i];
                    const prev = points[i-1];
                    if (prev.hOut || p.hIn) {
                        const c1 = prev.hOut ? `${prev.hOut.x} ${prev.hOut.y}` : `${prev.x} ${prev.y}`;
                        const c2 = p.hIn ? `${p.hIn.x} ${p.hIn.y}` : `${p.x} ${p.y}`;
                        d += `C ${c1}, ${c2}, ${p.x} ${p.y} `;
                    } else {
                        d += `L ${p.x} ${p.y} `;
                    }
                }
                return d;
            }
        };

        class NodeEditor {
            constructor(editor) {
                this.editor = editor;
                this.svgGizmo = document.getElementById('node-gizmo-svg');
                this.active = false;
                this.targetId = null;
                this.points = []; 
                this.selectedPointIndex = -1;
                this.dragMode = null; 
                this.dragIndex = -1;
                this.dragStart = {x:0, y:0};
            }

            activate(pathId) {
                if(this.targetId === pathId && this.active) return;
                this.targetId = pathId;
                this.active = true;
                this.selectedPointIndex = -1;
                this.parse();
                this.render();
            }

            deactivate() {
                this.active = false;
                this.targetId = null;
                this.svgGizmo.innerHTML = '';
                this.points = [];
            }

            parse() {
                const el = document.getElementById(this.targetId);
                if(!el) return;
                const d = el.getAttribute('d');
                this.points = PathUtils.parsePath(d);
            }

            updatePath() {
                const el = document.getElementById(this.targetId);
                if(!el) return;
                const newD = PathUtils.generatePathFromPoints(this.points);
                el.setAttribute('d', newD);
            }

            render() {
                this.svgGizmo.innerHTML = '';
                const g = Utils.createSVG('g', { id: 'node-gizmo-group' });
                
                this.points.forEach((p, i) => {
                    const isSelected = i === this.selectedPointIndex;
                    if (p.hIn) {
                        const line = Utils.createSVG('line', { x1: p.x, y1: p.y, x2: p.hIn.x, y2: p.hIn.y, class: 'gizmo-line' });
                        g.appendChild(line);
                        const c = Utils.createSVG('circle', { cx: p.hIn.x, cy: p.hIn.y, r: 4, class: 'gizmo-handle', 'data-type': 'hIn', 'data-idx': i });
                        g.appendChild(c);
                    }
                    if (p.hOut) {
                        const line = Utils.createSVG('line', { x1: p.x, y1: p.y, x2: p.hOut.x, y2: p.hOut.y, class: 'gizmo-line' });
                        g.appendChild(line);
                        const c = Utils.createSVG('circle', { cx: p.hOut.x, cy: p.hOut.y, r: 4, class: 'gizmo-handle', 'data-type': 'hOut', 'data-idx': i });
                        g.appendChild(c);
                    }
                    const anchor = Utils.createSVG('rect', { x: p.x - 5, y: p.y - 5, width: 10, height: 10, class: `node-anchor ${isSelected ? 'selected' : ''}`, 'data-type': 'anchor', 'data-idx': i });
                    g.appendChild(anchor);
                });
                this.svgGizmo.appendChild(g);
            }

            handleMouseDown(e) {
                if (!this.active) return;
                const target = e.target;
                if (!target.classList.contains('node-anchor') && !target.classList.contains('gizmo-handle')) {
                    this.selectedPointIndex = -1;
                    this.render();
                    return;
                }
                e.stopPropagation();
                const idx = parseInt(target.dataset.idx);
                const type = target.dataset.type;
                this.selectedPointIndex = idx;
                this.dragMode = type;
                this.dragIndex = idx;
                this.dragStart = Utils.getMousePos(e);
                
                const p = this.points[idx];
                this.initialPointState = { x: p.x, y: p.y, hIn: p.hIn ? {...p.hIn} : null, hOut: p.hOut ? {...p.hOut} : null };

                const move = (ev) => this.doDrag(ev);
                const end = () => { window.removeEventListener('mousemove', move); window.removeEventListener('mouseup', end); this.editor.saveState(); };
                window.addEventListener('mousemove', move);
                window.addEventListener('mouseup', end);
            }

            doDrag(e) {
                const pos = Utils.getMousePos(e);
                const dx = pos.x - this.dragStart.x;
                const dy = pos.y - this.dragStart.y;
                const p = this.points[this.dragIndex];
                const init = this.initialPointState;

                if (this.dragMode === 'anchor') {
                    p.x = init.x + dx; p.y = init.y + dy;
                    if(p.hIn) { p.hIn.x = init.hIn.x + dx; p.hIn.y = init.hIn.y + dy; }
                    if(p.hOut) { p.hOut.x = init.hOut.x + dx; p.hOut.y = init.hOut.y + dy; }
                } else if (this.dragMode === 'hOut') {
                    p.hOut.x = init.hOut.x + dx; p.hOut.y = init.hOut.y + dy;
                } else if (this.dragMode === 'hIn') {
                    p.hIn.x = init.hIn.x + dx; p.hIn.y = init.hIn.y + dy;
                }
                this.render(); this.updatePath();
            }

            deleteSelected() {
                if(this.selectedPointIndex !== -1 && this.points.length > 2) {
                    this.points.splice(this.selectedPointIndex, 1);
                    this.selectedPointIndex = -1;
                    this.render(); this.updatePath();
                    this.editor.saveState();
                }
            }
        }

        class App {
            constructor() {
                this.svg = document.getElementById('main-svg');
                this.layer = document.getElementById('drawing-layer');
                this.selectedId = null;
                this.tool = 'select'; 
                this.isDrawing = false;
                this.startPos = {x:0, y:0};
                this.currentShape = null;
                this.penPoints = [];
                this.nodeEditor = new NodeEditor(this);
                this.history = [];
                this.redoStack = [];
                this.hoverDelBtn = document.getElementById('hover-delete-btn');
                this.init();
            }

            init() {
                this.bindEvents();
                this.bindUI();
                this.renderLayers();
            }

            setTool(t) {
                this.tool = t;
                document.querySelectorAll('#toolbar .btn').forEach(b => b.classList.remove('active'));
                document.getElementById(`tool-${t}`).classList.add('active');
                if (t !== 'node') this.nodeEditor.deactivate();
                if (t === 'select' || t === 'node') this.svg.style.cursor = 'default';
                else { this.deselect(); this.svg.style.cursor = 'crosshair'; }
            }

            bindUI() {
                ['select', 'node', 'rect', 'circle', 'pen'].forEach(t => {
                    document.getElementById(`tool-${t}`).onclick = () => this.setTool(t);
                });

                const updateAttr = (attr, val) => {
                    const el = document.getElementById(this.selectedId);
                    if(el) { el.setAttribute(attr, val); this.saveState(); }
                };
                ['fill', 'stroke', 'opacity'].forEach(k => {
                    const el = document.getElementById(`inp-${k}`);
                    if(el) el.oninput = (e) => updateAttr(k, e.target.value);
                });

                // --- FIX: STROKE WIDTH ---
                // Manually bind the stroke width input because the generic loop logic had ID mismatch issues
                const swEl = document.getElementById('inp-stroke-width');
                swEl.oninput = (e) => updateAttr('stroke-width', e.target.value);

                // --- FIX: LIVE PREVIEW COLOR ---
                // Remove selection highlight when editing color
                const colorInputs = ['inp-fill', 'inp-stroke'];
                colorInputs.forEach(id => {
                    const input = document.getElementById(id);
                    input.addEventListener('focus', () => {
                        const el = document.getElementById(this.selectedId);
                        if(el) el.classList.add('editing-color');
                    });
                    input.addEventListener('blur', () => {
                        const el = document.getElementById(this.selectedId);
                        if(el) el.classList.remove('editing-color');
                    });
                });

                // RADIUS LOGIC
                const updateRadius = (val) => {
                    const el = document.getElementById(this.selectedId);
                    if(el && el.tagName === 'rect') {
                        el.setAttribute('rx', val);
                        el.setAttribute('ry', val);
                        document.getElementById('inp-radius-range').value = val;
                        document.getElementById('inp-radius-num').value = val;
                    }
                };
                document.getElementById('inp-radius-range').oninput = (e) => updateRadius(e.target.value);
                document.getElementById('inp-radius-num').oninput = (e) => updateRadius(e.target.value);


                document.getElementById('btn-topath').onclick = () => this.convertToPath();
                document.getElementById('btn-del').onclick = () => this.deleteSelection();
                document.getElementById('btn-dup').onclick = () => this.duplicateSelection();
                document.getElementById('btn-undo').onclick = () => this.undo();
                document.getElementById('btn-redo').onclick = () => this.redo();
                document.getElementById('btn-export').onclick = () => this.exportSVG();
                
                // Floating Delete Button Logic
                this.hoverDelBtn.onclick = (e) => {
                    e.stopPropagation(); // Prevent selecting the shape under it
                    if(this.hoverDelTargetId) {
                        this.select(this.hoverDelTargetId);
                        this.deleteSelection();
                        this.hoverDelBtn.style.display = 'none';
                    }
                };
            }

            bindEvents() {
                this.svg.addEventListener('mousedown', (e) => this.onStart(e));
                window.addEventListener('mousemove', (e) => this.onMove(e));
                window.addEventListener('mouseup', (e) => this.onEnd(e));
                this.svg.addEventListener('click', (e) => this.onClick(e));
                document.getElementById('node-gizmo-svg').addEventListener('mousedown', (e) => this.nodeEditor.handleMouseDown(e));

                // HOVER DELETE LOGIC
                this.svg.addEventListener('mouseover', (e) => {
                    if(e.target.classList.contains('vector-element') && e.target.id !== this.hoverDelTargetId) {
                        this.hoverDelTargetId = e.target.id;
                        this.showHoverDelete(e.target);
                    } else if (!e.target.classList.contains('vector-element') && !e.target.closest('#hover-delete-btn')) {
                        this.hoverDelBtn.style.display = 'none';
                        this.hoverDelTargetId = null;
                    }
                });

                window.addEventListener('keydown', (e) => {
                    if(e.key === 'Delete' || e.key === 'Backspace') {
                        if(this.tool === 'node' && this.nodeEditor.active) this.nodeEditor.deleteSelected();
                        else this.deleteSelection();
                    }
                    if(e.key === 'v') this.setTool('select');
                    if(e.key === 'n') this.setTool('node');
                    if(e.key === 'r') this.setTool('rect');
                    if(e.key === 'c') this.setTool('circle');
                    if(e.key === 'p') this.setTool('pen');
                    if(e.key === 'z' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); if(e.shiftKey) this.redo(); else this.undo(); }
                    if(e.key === 'Enter') { if(this.tool === 'pen') this.finishPen(); }
                });
            }

            showHoverDelete(el) {
                const bbox = el.getBBox();
                const btn = this.hoverDelBtn;
                btn.style.display = 'flex';
                
                // Position button at top-right of bounding box
                // Need to account for SVG viewBox scale
                const artboard = document.getElementById('artboard');
                const rect = artboard.getBoundingClientRect();
                const scaleX = rect.width / 800;
                const scaleY = rect.height / 600;

                btn.style.left = (bbox.x + bbox.width) * scaleX + 'px';
                btn.style.top = bbox.y * scaleY + 'px';
            }

            getMouse(e) { return Utils.getMousePos(e); }

            onStart(e) {
                if (e.target.closest('#node-gizmo-svg') || e.target.closest('#hover-delete-btn')) return;
                const pos = this.getMouse(e);
                this.startPos = pos;

                if (this.tool === 'select') {
                    if (e.target.classList.contains('vector-element')) {
                        this.select(e.target.id);
                        this.isDrawing = true;
                        this.dragStart = pos;
                        const el = document.getElementById(this.selectedId);
                        const transforms = el.transform.baseVal;
                        if (transforms.length === 0 || transforms.getItem(0).type !== SVGTransform.SVG_TRANSFORM_TRANSLATE) {
                            const translate = this.svg.createSVGTransform();
                            translate.setTranslate(0, 0);
                            el.transform.baseVal.insertItemBefore(translate, 0);
                        }
                        this.initialTx = transforms.getItem(0).matrix.e;
                        this.initialTy = transforms.getItem(0).matrix.f;
                    } else this.deselect();
                }
                else if (this.tool === 'rect') {
                    this.isDrawing = true;
                    this.currentShape = Utils.createSVG('rect', {
                        x: pos.x, y: pos.y, width: 0, height: 0, rx: 0, ry: 0,
                        fill: '#000', stroke: 'none', class: 'vector-element'
                    });
                    this.layer.appendChild(this.currentShape);
                }
                else if (this.tool === 'circle') {
                    this.isDrawing = true;
                    this.currentShape = Utils.createSVG('circle', {
                        cx: pos.x, cy: pos.y, r: 0,
                        fill: '#000', stroke: 'none', class: 'vector-element'
                    });
                    this.layer.appendChild(this.currentShape);
                }
            }

            onClick(e) {
                if (e.target.closest('#node-gizmo-svg') || e.target.closest('#hover-delete-btn')) return;

                if (this.tool === 'pen') {
                    e.stopPropagation();
                    const pos = this.getMouse(e);
                    
                    // Check if clicking first point to close path
                    if (this.penPoints.length > 2) {
                        const first = this.penPoints[0];
                        const dist = Math.sqrt(Math.pow(pos.x - first.x, 2) + Math.pow(pos.y - first.y, 2));
                        if(dist < 10) {
                            this.finishPen();
                            return;
                        }
                    }

                    if (!this.currentShape) {
                        this.currentShape = Utils.createSVG('path', {
                            d: `M ${pos.x} ${pos.y}`, fill: 'none', stroke: '#000', 'stroke-width': 2, class: 'vector-element'
                        });
                        this.currentShape.id = Utils.uid();
                        this.layer.appendChild(this.currentShape);
                        this.penPoints = [{x: pos.x, y: pos.y, hIn:null, hOut:null}];
                    } else {
                        this.penPoints.push({x: pos.x, y: pos.y, hIn:null, hOut:null});
                        this.updatePenPath();
                    }
                }
            }

            onMove(e) {
                if (!this.isDrawing) return;
                const pos = this.getMouse(e);

                if (this.tool === 'select' && this.selectedId) {
                    const el = document.getElementById(this.selectedId);
                    const dx = pos.x - this.dragStart.x;
                    const dy = pos.y - this.dragStart.y;
                    const t = el.transform.baseVal.getItem(0);
                    t.setTranslate(this.initialTx + dx, this.initialTy + dy);
                    if(this.nodeEditor.active) this.nodeEditor.render();
                    // Also move delete button if visible
                    if(this.hoverDelTargetId === this.selectedId) this.showHoverDelete(el);
                }
                else if (this.tool === 'rect') {
                    const w = pos.x - this.startPos.x;
                    const h = pos.y - this.startPos.y;
                    this.currentShape.setAttribute('x', w < 0 ? pos.x : this.startPos.x);
                    this.currentShape.setAttribute('y', h < 0 ? pos.y : this.startPos.y);
                    this.currentShape.setAttribute('width', Math.abs(w));
                    this.currentShape.setAttribute('height', Math.abs(h));
                }
                else if (this.tool === 'circle') {
                    const r = Math.sqrt(Math.pow(pos.x - this.startPos.x, 2) + Math.pow(pos.y - this.startPos.y, 2));
                    this.currentShape.setAttribute('r', r);
                }
                else if (this.tool === 'pen') {
                    if (e.buttons === 1 && this.penPoints.length > 0) {
                        const last = this.penPoints[this.penPoints.length-1];
                        last.hOut = { x: pos.x, y: pos.y };
                        this.updatePenPath();
                    }
                }
            }

            onEnd(e) {
                if (this.isDrawing) {
                    if (this.tool !== 'select') {
                        if(this.currentShape) {
                            // --- FIX: ZERO SIZE PROTECTION ---
                            let isTooSmall = false;
                            if(this.tool === 'rect') {
                                const w = parseFloat(this.currentShape.getAttribute('width'));
                                const h = parseFloat(this.currentShape.getAttribute('height'));
                                if(w < 5 || h < 5) isTooSmall = true;
                            } else if (this.tool === 'circle') {
                                const r = parseFloat(this.currentShape.getAttribute('r'));
                                if(r < 5) isTooSmall = true;
                            }

                            if(isTooSmall) {
                                this.currentShape.remove();
                                Utils.toast("Shape too small");
                            } else {
                                this.currentShape.id = Utils.uid();
                                this.select(this.currentShape.id);
                                this.saveState();
                            }
                        }
                    } else {
                        this.saveState();
                    }
                }
                if(this.tool !== 'pen') { this.isDrawing = false; this.currentShape = null; }
            }

            finishPen() {
                if(this.tool === 'pen' && this.currentShape) {
                    this.select(this.currentShape.id);
                    this.currentShape = null;
                    this.penPoints = [];
                    this.setTool('select');
                    this.saveState();
                }
            }

            updatePenPath() {
                if(!this.currentShape) return;
                const d = PathUtils.generatePathFromPoints(this.penPoints);
                this.currentShape.setAttribute('d', d);
            }

            select(id) {
                this.deselect();
                this.selectedId = id;
                const el = document.getElementById(id);
                el.classList.add('selected');
                document.getElementById('selection-props').style.display = 'block';
                
                // Populate Common Inputs
                document.getElementById('inp-fill').value = Utils.rgbToHex(el.getAttribute('fill'));
                document.getElementById('inp-stroke').value = Utils.rgbToHex(el.getAttribute('stroke'));
                document.getElementById('inp-stroke-width').value = el.getAttribute('stroke-width') || 1;
                document.getElementById('inp-opacity').value = el.getAttribute('opacity') || 1;

                // Radius Logic
                const radiusGroup = document.getElementById('radius-group');
                if (el.tagName === 'rect') {
                    radiusGroup.style.display = 'block';
                    const rx = el.getAttribute('rx') || 0;
                    document.getElementById('inp-radius-range').value = rx;
                    document.getElementById('inp-radius-num').value = rx;
                } else {
                    radiusGroup.style.display = 'none';
                }

                this.renderLayers();
            }

            deselect() {
                if(this.selectedId) {
                    const el = document.getElementById(this.selectedId);
                    if(el) el.classList.remove('selected');
                }
                this.selectedId = null;
                document.getElementById('selection-props').style.display = 'none';
                this.nodeEditor.deactivate();
                this.hoverDelBtn.style.display = 'none';
                this.renderLayers();
            }

            deleteSelection() {
                if(this.selectedId) { document.getElementById(this.selectedId).remove(); this.deselect(); this.saveState(); }
            }

            duplicateSelection() {
                if(!this.selectedId) return;
                const el = document.getElementById(this.selectedId);
                const clone = el.cloneNode(true);
                clone.id = Utils.uid();
                clone.classList.remove('selected');
                const t = clone.transform.baseVal;
                if(t.length === 0 || t.getItem(0).type !== SVGTransform.SVG_TRANSFORM_TRANSLATE) {
                    const tr = this.svg.createSVGTransform(); tr.setTranslate(10, 10);
                    t.insertItemBefore(tr, 0);
                } else {
                    const m = t.getItem(0).matrix; t.getItem(0).setTranslate(m.e + 10, m.f + 10);
                }
                this.layer.appendChild(clone);
                this.select(clone.id);
                this.saveState();
            }

            convertToPath() {
                if(!this.selectedId) return;
                const el = document.getElementById(this.selectedId);
                if(el.tagName === 'path') return;

                const d = PathUtils.shapeToPath(el);
                const path = Utils.createSVG('path', {
                    d: d,
                    fill: el.getAttribute('fill') || '#000',
                    stroke: el.getAttribute('stroke'),
                    'stroke-width': el.getAttribute('stroke-width'),
                    transform: el.getAttribute('transform'),
                    class: 'vector-element'
                });
                this.layer.replaceChild(path, el);
                this.select(path.id);
                this.saveState();
                this.setTool('node');
                this.nodeEditor.activate(this.selectedId);
                Utils.toast("Converted to Path");
            }

            renderLayers() {
                const list = document.getElementById('layers-list');
                list.innerHTML = '';
                Array.from(this.layer.children).reverse().forEach(el => {
                    const row = document.createElement('div');
                    row.className = `layer-item ${el.id === this.selectedId ? 'active' : ''}`;
                    let icon = 'fa-vector-square';
                    if(el.tagName === 'rect') icon = 'fa-square';
                    if(el.tagName === 'circle') icon = 'fa-circle';
                    row.innerHTML = `<i class="fas ${icon}"></i> ${el.tagName} <span style="margin-left:auto; opacity:0.5;">${el.id.substr(-4)}</span>`;
                    row.onclick = () => this.select(el.id);
                    list.appendChild(row);
                });
            }

            saveState() {
                if(this.history.length > 20) this.history.shift();
                this.history.push(this.layer.innerHTML);
                this.redoStack = [];
            }

            undo() {
                if(this.history.length <= 1) return;
                this.redoStack.push(this.history.pop());
                this.layer.innerHTML = this.history[this.history.length-1];
                this.deselect();
            }

            redo() {
                if(this.redoStack.length === 0) return;
                const next = this.redoStack.pop();
                this.history.push(next);
                this.layer.innerHTML = next;
                this.deselect();
            }
            
            exportSVG() {
                const s = new XMLSerializer().serializeToString(this.svg);
                const b = new Blob([s], {type:'image/svg+xml'});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(b);
                a.download = 'brutalist-design.svg';
                a.click();
            }
        }

        Utils.rgbToHex = (col) => {
            if(!col || col === 'none') return '#000000';
            if(col.startsWith('#')) return col;
            const ctx = document.createElement('canvas').getContext('2d');
            ctx.fillStyle = col;
            return ctx.fillStyle;
        }

        const app = new App();
    </script>
</body>
</html>