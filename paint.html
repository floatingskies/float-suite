<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Paint.web - Pro Web Editor</title>
    
    <meta name="theme-color" content="#FFDE59">
    <meta name="description" content="Professional Layer-Based Image Editor">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        :root {
            --c-bg: #f0f2f5;         
            --c-panel: #ffffff;       
            --c-surface: #f4f4f4;     
            --c-text: #1a1a1a;       
            --c-border: #cccccc;      
            --c-primary: #FFDE59;     
            --c-secondary: #FF90E8;   
            --c-accent: #23C9FF;      
            --c-danger: #FF4D4D;      
            --border-width: 2px;
            --shadow-hard: 4px 4px 0px rgba(0,0,0,0.1);
            --font-ui: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            --font-label: 'Impact', 'Arial Black', sans-serif;
            --header-h: 50px;
            --sidebar-w: 280px;
            --bottom-h: 180px;
        }

        [data-theme="dark"] {
            --c-bg: #121212;
            --c-panel: #1e1e1e;
            --c-surface: #2a2a2a;
            --c-text: #e0e0e0;
            --c-border: #444444;
            --c-primary: #bfa300;
            --shadow-hard: 4px 4px 0px rgba(255,255,255,0.1);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; outline: none; user-select: none; -webkit-user-select: none; }
        
        body {
            background-color: var(--c-bg);
            color: var(--c-text);
            font-family: var(--font-ui);
            font-size: 12px;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- UI Components --- */
        .btn {
            background: var(--c-panel);
            border: var(--border-width) solid var(--c-border);
            color: var(--c-text);
            padding: 6px 10px;
            font-family: var(--font-ui);
            font-weight: 600;
            text-transform: uppercase;
            cursor: pointer;
            display: inline-flex; align-items: center; justify-content: center; gap: 6px;
            transition: all 0.1s;
            flex-shrink: 0;
            font-size: 10px;
            border-radius: 4px;
        }
        .btn:hover { 
            background: var(--c-primary); 
            transform: translateY(-1px); 
            color: #000;
            border-color: #000;
        }
        .btn:active, .btn.active { 
            background: var(--c-secondary); 
            transform: translateY(1px); 
            color: #000;
            border-color: #000;
        }
        .btn-icon { width: 36px; height: 36px; padding: 0; font-size: 14px; border-radius: 6px; }
        .btn-danger { color: var(--c-danger); border-color: var(--c-danger); }
        .btn-danger:hover { background: var(--c-danger); color: #fff; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }

        input[type="range"] { 
            width: 100%; accent-color: var(--c-primary); cursor: pointer; height: 4px; background: var(--c-border);
            appearance: none; border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%; background: var(--c-primary); border: 2px solid var(--c-text); cursor: pointer;
        }

        input[type="number"], input[type="text"] {
            background: var(--c-surface); border: 2px solid var(--c-border);
            color: var(--c-text); font-family: var(--font-ui); font-weight: 500;
            padding: 4px; width: 100%; border-radius: 4px;
        }
        
        /* --- Layout --- */
        .topbar {
            height: var(--header-h);
            background: var(--c-panel);
            border-bottom: var(--border-width) solid var(--c-border);
            display: flex; align-items: center; padding: 0 15px; gap: 15px;
            z-index: 100;
            flex-shrink: 0;
        }
        .logo { font-family: var(--font-label); font-size: 20px; font-weight: 900; color: var(--c-text); }
        
        .menubar {
            height: 30px;
            background: var(--c-bg);
            border-bottom: 1px solid var(--c-border);
            display: flex; align-items: center; padding: 0 10px; gap: 10px;
            flex-shrink: 0;
        }
        .menu-item { padding: 4px 10px; cursor: pointer; font-weight: 700; font-size: 10px; border-radius: 4px; text-transform: uppercase; }
        .menu-item:hover { background: var(--c-surface); color: var(--c-primary); }

        #app { display: flex; flex: 1; overflow: hidden; position: relative; height: calc(100vh - var(--header-h) - 30px - var(--bottom-h)); }
        
        /* --- Left Sidebar (Tools & Adjustments) --- */
        .toolbar {
            width: var(--sidebar-w);
            background: var(--c-panel);
            border-right: var(--border-width) solid var(--c-border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            flex-shrink: 0;
            padding: 10px;
            gap: 15px;
        }

        .tool-group {
            display: flex; flex-direction: column; gap: 8px;
        }
        .tool-label {
            font-size: 10px; font-weight: 900; text-transform: uppercase; color: #888;
            margin-bottom: 4px; letter-spacing: 1px;
        }
        .tools-grid {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px;
        }
        .tools-2-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 6px;
        }
        
        .adj-row { display: flex; flex-direction: column; gap: 4px; }
        .adj-header { display: flex; justify-content: space-between; font-size: 10px; font-weight: bold; }

        /* --- Viewport --- */
        .viewport {
            flex: 1;
            background-color: #888; 
            background-image:
                linear-gradient(45deg, #777 25%, transparent 25%),
                linear-gradient(-45deg, #777 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #777 75%),
                linear-gradient(-45deg, transparent 75%, #777 75%);
            background-size: 20px 20px;
            overflow: hidden; 
            position: relative;
            display: flex; align-items: center; justify-content: center;
            touch-action: none;
        }
        .viewport[data-cursor="move"] { cursor: grab; }
        .viewport[data-cursor="move"].grabbing { cursor: grabbing; }
        .viewport[data-cursor="crosshair"] { cursor: crosshair; }
        
        #canvas-wrapper {
            position: absolute;
            top: 0; left: 0;
            background: #fff; 
            box-shadow: 0 0 50px rgba(0,0,0,0.3);
            transform-origin: 0 0; 
        }
        canvas { position: absolute; top: 0; left: 0; pointer-events: none; image-rendering: pixelated; }
        canvas.active-canvas { pointer-events: auto; }
        #preview-canvas { z-index: 999; pointer-events: none; }

        /* --- BOTTOM BAR (Layers & Swatches) --- */
        .bottom-bar {
            height: var(--bottom-h);
            background: var(--c-panel);
            border-top: var(--border-width) solid var(--c-border);
            display: flex;
            flex-shrink: 0;
            overflow: hidden;
        }

        .bb-section {
            padding: 10px;
            display: flex;
            flex-direction: column;
        }
        #bb-layers {
            flex: 3;
            border-right: 1px solid var(--c-border);
        }
        #bb-swatches {
            flex: 1;
        }

        .bb-header {
            font-size: 11px; font-weight: 900; text-transform: uppercase;
            margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;
            letter-spacing: 0.5px;
        }
        
        .layer-controls {
            display: flex; gap: 5px; margin-bottom: 8px;
        }

        .layers-list {
            flex: 1;
            overflow-y: auto;
            display: flex; flex-direction: column; gap: 6px;
        }
        .layer-item {
            background: var(--c-surface);
            border: 2px solid var(--c-border);
            padding: 4px 8px;
            display: flex; align-items: center; gap: 8px;
            cursor: pointer;
            transition: 0.1s;
            position: relative;
            border-radius: 4px;
            height: 40px;
        }
        .layer-item:hover { background: #eef; border-color: var(--c-accent); }
        .layer-item.active { background: var(--c-primary); color: #000; border-color: #000; }
        
        .layer-thumb { 
            width: 40px; height: 32px; background: #fff; 
            border: 1px solid #000; border-radius: 2px; display: flex; align-items: center; justify-content: center; 
            overflow: hidden; flex-shrink: 0; pointer-events: none;
        }
        .layer-thumb canvas { position: static; width: 100%; height: 100%; object-fit: contain; }
        .layer-name { flex: 1; font-weight: 600; font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; pointer-events: none;}
        .layer-vis { cursor: pointer; width: 20px; text-align: center; color: #666; }
        .layer-vis:hover { color: #000; }

        /* --- Swatches --- */
        #swatches {
            display: flex; flex-wrap: wrap; gap: 6px; align-content: flex-start;
            overflow-y: auto;
        }
        .swatch {
            width: 24px; height: 24px; border-radius: 50%; border: 2px solid rgba(0,0,0,0.1);
            cursor: pointer; transition: transform 0.1s; position: relative;
        }
        .swatch:hover { transform: scale(1.2); z-index: 2; border-color: #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .swatch.add-color-btn {
            background: #eee; display: flex; align-items: center; justify-content: center; font-size: 12px; color: #666; border-radius: 4px;
        }
        .swatch.add-color-btn:hover { background: #ddd; }

        /* --- Modals & Toasts --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 2000;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(2px);
        }
        .modal-overlay.hidden { display: none; pointer-events: none; }
        
        .modal-box {
            background: var(--c-panel);
            border: var(--border-width) solid var(--c-border);
            width: 90%; max-width: 400px;
            box-shadow: 10px 10px 0px rgba(0,0,0,0.2);
            display: flex; flex-direction: column;
            border-radius: 8px; overflow: hidden;
        }
        
        .modal-header { 
            background: var(--c-primary); color: #000;
            padding: 12px; font-family: var(--font-label); font-size: 16px;
            font-weight: 900; text-transform: uppercase;
            display: flex; justify-content: space-between; align-items: center;
        }
        .modal-body { padding: 20px; display:flex; flex-direction:column; gap:15px;}
        .modal-footer { padding: 15px; background: var(--c-bg); border-top: 1px solid var(--c-border); display: flex; justify-content: flex-end; gap: 10px; }

        .toast-container {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; gap: 8px; z-index: 3000; pointer-events: none;
        }
        .toast {
            background: var(--c-text); color: var(--c-bg);
            padding: 10px 20px; border-radius: 50px;
            font-weight: 600; font-size: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            animation: popUp 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popUp { from {transform: translateY(20px) scale(0.9); opacity: 0;} to {transform: translateY(0) scale(1); opacity: 1;} }

        #text-tool-input {
            position: absolute; background: rgba(255, 255, 255, 0.95);
            border: 2px dashed #000; padding: 5px;
            font-family: sans-serif; font-weight: bold; color: #000;
            display: none; z-index: 1000; min-width: 50px; outline: none; border-radius: 4px;
        }

        #clone-cursor-ui {
            position: absolute; pointer-events: none;
            border: 1px solid #000; background: rgba(255, 255, 255, 0.4);
            display: none; z-index: 1001; border-radius: 50%;
        }
        #clone-source-indicator {
            position: absolute; width: 14px; height: 14px;
            background: var(--c-accent); border: 2px solid #000; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            display: none; z-index: 1001; box-shadow: 0 0 0 4px rgba(255,255,255,0.5);
        }
        
        /* Hidden inputs */
        .hidden-file { display: none; }
    </style>
</head>
<body>

    <!-- TOP BAR -->
    <div class="topbar">
        <div class="logo">PAINT<span style="color:var(--c-primary)">.WEB</span></div>

        <div class="res-group" style="display:flex; gap:5px; align-items:center;">
            <button class="btn btn-icon" onclick="App.ui.openModal('modal-resize')" title="Canvas Size"><i class="fas fa-expand"></i></button>
            <div style="width: 1px; height: 20px; background: var(--c-border);"></div>
            <input type="file" id="file-input" accept="image/*" class="hidden-file">
            <button class="btn" onclick="document.getElementById('file-input').click()"><i class="fas fa-folder-open"></i> Open</button>
            <button class="btn" id="btn-export"><i class="fas fa-save"></i> Export</button>
            <div style="width: 1px; height: 20px; background: var(--c-border);"></div>
            <button class="btn btn-icon" id="btn-undo" title="Undo (Ctrl+Z)" disabled><i class="fas fa-undo"></i></button>
            <button class="btn btn-icon" id="btn-redo" title="Redo (Ctrl+Y)" disabled><i class="fas fa-redo"></i></button>
        </div>
    </div>

    <div class="menubar">
        <div class="menu-item" onclick="App.ui.openModal('modal-filters')">Effects & Filters</div>
        <div style="flex:1"></div>
        <div class="menu-item" id="zoom-level">100%</div>
        <div class="menu-item" onclick="App.toggleTheme()"><i class="fas fa-adjust"></i></div>
    </div>

    <!-- MAIN APP AREA (Tools + Viewport) -->
    <div id="app">
        <!-- LEFT SIDEBAR -->
        <nav class="toolbar">
            
            <div class="tool-group">
                <div class="tool-label">Tools</div>
                <div class="tools-grid">
                    <button class="btn btn-icon active" data-tool="move" title="Move Canvas (Space)"><i class="fas fa-arrows-alt"></i></button>
                    <button class="btn btn-icon" data-tool="pan-layer" title="Move Layer (V)"><i class="fas fa-expand-arrows-alt"></i></button>
                    <button class="btn btn-icon" data-tool="crop" title="Crop (C)"><i class="fas fa-crop-alt"></i></button>
                    <button class="btn btn-icon" data-tool="picker" title="Eyedropper (I)"><i class="fas fa-eye-dropper"></i></button>
                    
                    <button class="btn btn-icon" data-tool="brush" title="Brush (B)"><i class="fas fa-paint-brush"></i></button>
                    <button class="btn btn-icon" data-tool="eraser" title="Eraser (E)"><i class="fas fa-eraser"></i></button>
                    <button class="btn btn-icon" data-tool="fill" title="Fill Bucket (G)"><i class="fas fa-fill-drip"></i></button>
                    <button class="btn btn-icon" data-tool="text" title="Text (T)"><i class="fas fa-font"></i></button>

                    <button class="btn btn-icon" data-tool="clone" title="Clone Stamp (S)"><i class="fas fa-stamp"></i></button>
                    <button class="btn btn-icon" data-tool="line" title="Line"><i class="fas fa-slash"></i></button>
                    <button class="btn btn-icon" data-tool="rect" title="Rectangle"><i class="far fa-square"></i></button>
                    <button class="btn btn-icon" data-tool="circle" title="Circle"><i class="far fa-circle"></i></button>
                </div>
            </div>

            <div class="tool-group">
                <div class="tool-label">Brush Settings</div>
                <div class="adj-row">
                    <div class="adj-header"><span>Size</span> <span id="lbl-size">10px</span></div>
                    <input type="range" id="brush-size" min="1" max="200" value="10">
                </div>
                <div class="adj-row">
                     <div class="adj-header"><span>Color</span></div>
                     <div style="display:flex; gap: 5px; align-items:center;">
                        <input type="color" id="native-color-picker" style="width:30px; height:30px; padding:0; border:none; background:none; cursor:pointer;">
                        <span id="hex-display" style="font-family: monospace; font-size: 11px;">#000000</span>
                     </div>
                </div>
            </div>

            <div class="tool-group">
                <div class="tool-label">Transform</div>
                <div class="tools-2-grid">
                    <button class="btn" onclick="App.transformLayer('flip-h')"><i class="fas fa-arrows-alt-h"></i> Flip H</button>
                    <button class="btn" onclick="App.transformLayer('flip-v')"><i class="fas fa-arrows-alt-v"></i> Flip V</button>
                    <button class="btn" onclick="App.transformLayer('rotate-cw')"><i class="fas fa-redo"></i> Rot 90°</button>
                    <button class="btn" onclick="App.transformLayer('rotate-ccw')"><i class="fas fa-undo"></i> Rot -90°</button>
                </div>
            </div>

            <div class="tool-group">
                <div class="tool-label">Live Adjustments</div>
                <div class="adj-row">
                    <div class="adj-header"><span>Opacity</span> <span id="val-op">100%</span></div>
                    <input type="range" class="adj-slider" id="adj-opacity" data-prop="opacity" min="0" max="1" step="0.05" value="1">
                </div>
                <div class="adj-row">
                    <div class="adj-header"><span>Brightness</span></div>
                    <input type="range" class="adj-slider" data-prop="brightness" min="-100" max="100" value="0">
                </div>
                <div class="adj-row">
                    <div class="adj-header"><span>Contrast</span></div>
                    <input type="range" class="adj-slider" data-prop="contrast" min="-100" max="100" value="0">
                </div>
                <div class="adj-row">
                    <div class="adj-header"><span>Saturation</span></div>
                    <input type="range" class="adj-slider" data-prop="saturate" min="-100" max="100" value="0">
                </div>
                <div class="adj-row">
                    <div class="adj-header"><span>Blur</span></div>
                    <input type="range" class="adj-slider" data-prop="blur" min="0" max="10" step="0.5" value="0">
                </div>
                <button class="btn" id="btn-apply-adj" style="background:var(--c-surface)">Apply Filters</button>
                <button class="btn" id="btn-reset-adj">Reset</button>
            </div>
        </nav>

        <!-- MAIN VIEWPORT -->
        <main class="viewport" id="viewport" data-cursor="default">
            <div id="canvas-wrapper"></div>
            <input type="text" id="text-tool-input" placeholder="Type here...">
            <div id="clone-cursor-ui"></div>
            <div id="clone-source-indicator"></div>
        </main>
    </div>

    <!-- BOTTOM BAR (Layers + Swatches) -->
    <div class="bottom-bar">
        <div class="bb-section" id="bb-layers">
            <div class="bb-header">
                <span><i class="fas fa-layer-group"></i> Layers</span>
                <small style="font-weight:normal; font-size:9px;">DRAG TO SORT</small>
            </div>
            <div class="layer-controls">
                <button class="btn btn-icon" id="btn-add-layer" title="New Layer"><i class="fas fa-plus"></i></button>
                <button class="btn btn-icon" id="btn-merge-down" title="Merge Down"><i class="fas fa-arrow-down"></i></button>
                <button class="btn btn-icon" id="btn-dup-layer" title="Duplicate"><i class="fas fa-copy"></i></button>
                <button class="btn btn-icon btn-danger" id="btn-del-layer" title="Delete Layer"><i class="fas fa-trash"></i></button>
            </div>
            <div class="layers-list" id="layers-list"></div>
        </div>

        <div class="bb-section" id="bb-swatches">
            <div class="bb-header">
                <span><i class="fas fa-palette"></i> Colors</span>
            </div>
            <div id="swatches"></div>
        </div>
    </div>

    <!-- MODALS -->
    <div class="modal-overlay hidden" id="modal-overlay">
        
        <!-- EXPORT MODAL -->
        <div class="modal-box hidden" id="modal-settings">
            <div class="modal-header"><span>Export Image</span><i class="fas fa-save"></i></div>
            <div class="modal-body">
                <div class="adj-row"><label>Filename</label><input type="text" id="exp-name" value="masterpiece"></div>
                <div class="adj-row"><label>Format</label>
                    <select id="exp-fmt" style="padding: 5px;">
                        <option value="image/png">PNG</option>
                        <option value="image/jpeg">JPG</option>
                        <option value="image/webp">WebP</option>
                    </select>
                </div>
                <div class="adj-row"><label>Quality</label><input type="range" id="exp-qual" min="0.1" max="1" step="0.1" value="1"></div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="App.ui.closeModal()">Cancel</button>
                <button class="btn" onclick="App.exportImage()">Download</button>
            </div>
        </div>

        <!-- RESIZE MODAL -->
        <div class="modal-box hidden" id="modal-resize">
            <div class="modal-header"><span>Canvas Size</span><i class="fas fa-expand"></i></div>
            <div class="modal-body">
                <div class="tools-2-grid">
                    <div>
                        <label>Width</label>
                        <input type="number" id="inp-w" value="1280">
                    </div>
                    <div>
                        <label>Height</label>
                        <input type="number" id="inp-h" value="720">
                    </div>
                </div>
                <label style="display:flex; align-items:center; gap:5px; font-size:11px; margin-top:5px;">
                    <input type="checkbox" id="chk-keep-ratio"> Keep Aspect Ratio
                </label>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="App.ui.closeModal()">Cancel</button>
                <button class="btn" onclick="App.resizeCanvasFromModal()">Apply</button>
            </div>
        </div>

        <!-- FILTERS MODAL -->
        <div class="modal-box hidden" id="modal-filters">
            <div class="modal-header"><span>Effects</span><i class="fas fa-magic"></i></div>
            <div class="modal-body">
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <button class="btn filter-btn" data-f="invert">INVERT</button>
                    <button class="btn filter-btn" data-f="grayscale">GRAYSCALE</button>
                    <button class="btn filter-btn" data-f="sepia">SEPIA</button>
                    <button class="btn filter-btn" data-f="noise">NOISE</button>
                    <button class="btn filter-btn" data-f="sharpen">SHARPEN</button>
                    <button class="btn filter-btn" data-f="emboss">EMBOSS</button>
                    <button class="btn filter-btn" data-f="edge">EDGE DETECT</button>
                    <button class="btn filter-btn" data-f="pixelate">PIXELATE</button>
                </div>
            </div>
            <div class="modal-footer"><button class="btn" onclick="App.ui.closeModal()">Close</button></div>
        </div>
    </div>

    <script>
        const Utils = {
            uid: () => 'lyr-' + Math.random().toString(36).substr(2, 5),
            toast: (msg) => {
                const c = document.getElementById('toast-container') || (() => {
                    const nc = document.createElement('div'); nc.id='toast-container'; nc.className='toast-container'; document.body.appendChild(nc); return nc;
                })();
                const t = document.createElement('div');
                t.className = 'toast'; t.innerText = msg;
                c.appendChild(t);
                setTimeout(() => { t.style.opacity = '0'; setTimeout(() => t.remove(), 300); }, 2000);
            }
        };

        class HistorySystem {
            constructor(limit = 20) {
                this.stack = [];
                this.redoStack = [];
                this.limit = limit;
                this.isRestoring = false;
            }

            async save(layers, w, h) {
                if(this.isRestoring) return;
                
                const state = {
                    w, h,
                    layers: layers.map(l => ({
                        id: l.id, name: l.name, x: l.x, y: l.y,
                        visible: l.visible, opacity: l.opacity,
                        filter: l.canvas.style.filter,
                        data: l.canvas.toDataURL()
                    })),
                    activeId: App.activeLayerId
                };
                
                this.stack.push(JSON.stringify(state)); 
                if (this.stack.length > this.limit) this.stack.shift();
                this.redoStack = [];
                this.updateUI();
            }

            async restore(stateStr) {
                this.isRestoring = true;
                const state = JSON.parse(stateStr);
                
                if (state.w !== App.width || state.h !== App.height) {
                    App.resizeCanvas(state.w, state.h, false);
                }

                App.ui.wrapper.innerHTML = '';
                App.ui.wrapper.appendChild(App.ui.previewCanvas); 
                App.layers = [];

                for (const savedL of state.layers) {
                    const canvas = document.createElement('canvas');
                    canvas.width = state.w; canvas.height = state.h;
                    canvas.id = savedL.id;
                    const ctx = canvas.getContext('2d');
                    
                    const img = new Image();
                    await new Promise(r => { img.onload = r; img.src = savedL.data; });
                    ctx.drawImage(img, 0, 0);

                    const layer = {
                        id: savedL.id, name: savedL.name,
                        canvas, ctx,
                        x: savedL.x, y: savedL.y,
                        visible: savedL.visible, opacity: savedL.opacity
                    };
                    layer.canvas.style.filter = savedL.filter || 'none';
                    
                    App.layers.push(layer);
                    App.ui.wrapper.appendChild(canvas);
                }

                App.activeLayerId = state.activeId;
                App.renderLayerDOM();
                App.renderLayerList();
                App.updateLayerThumb(App.activeLayerId);
                App.syncSidebarUI();
                
                this.isRestoring = false;
            }

            async undo() {
                if (this.stack.length <= 1 || this.isRestoring) return;
                this.isRestoring = true;
                const current = this.stack.pop(); 
                this.redoStack.push(current);
                await this.restore(this.stack[this.stack.length - 1]);
                this.isRestoring = false;
                this.updateUI();
                Utils.toast('Undo');
            }

            async redo() {
                if (this.redoStack.length === 0 || this.isRestoring) return;
                this.isRestoring = true;
                const next = this.redoStack.pop();
                this.stack.push(next);
                await this.restore(next);
                this.isRestoring = false;
                this.updateUI();
                Utils.toast('Redo');
            }

            updateUI() {
                const undoBtn = document.getElementById('btn-undo');
                const redoBtn = document.getElementById('btn-redo');
                undoBtn.disabled = this.stack.length <= 1;
                redoBtn.disabled = this.redoStack.length === 0;
                undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1';
                redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1';
            }
        }

        const App = {
            width: 1280,
            height: 720,
            layers: [],
            activeLayerId: null,
            tool: 'move',
            color: '#000000',
            brushSize: 10,
            zoom: 1,
            pan: {x: 0, y: 0},
            history: new HistorySystem(),
            
            cloneState: { active: false, srcX: 0, srcY: 0, snapshot: null },
            isDrawing: false,
            startX: 0, startY: 0,
            snapshot: null,
            
            ui: {
                wrapper: document.getElementById('canvas-wrapper'),
                list: document.getElementById('layers-list'),
                viewport: document.getElementById('viewport'),
                previewCanvas: null,
                previewCtx: null,
                textInput: document.getElementById('text-tool-input'),
                cloneCursor: document.getElementById('clone-cursor-ui'),
                sourceIndicator: document.getElementById('clone-source-indicator'),
                overlay: document.getElementById('modal-overlay'),
                openModal: (id) => {
                    document.querySelectorAll('.modal-box').forEach(b => b.classList.add('hidden'));
                    document.getElementById(id).classList.remove('hidden');
                    App.ui.overlay.classList.remove('hidden');
                    // Pre-fill resize values
                    if(id === 'modal-resize') {
                        document.getElementById('inp-w').value = App.width;
                        document.getElementById('inp-h').value = App.height;
                    }
                },
                closeModal: () => App.ui.overlay.classList.add('hidden')
            },

            init() {
                this.ui.previewCanvas = document.createElement('canvas');
                this.ui.previewCanvas.id = 'preview-canvas';
                this.ui.previewCtx = this.ui.previewCanvas.getContext('2d');
                this.ui.wrapper.appendChild(this.ui.previewCanvas);
                
                this.resizeCanvas(this.width, this.height, false);
                this.addLayer('Background', '#ffffff');
                this.history.save(this.layers, this.width, this.height);
                
                this.initSwatches();
                this.bindEvents();
                this.centerCanvas();
            },

            centerCanvas() {
                const vpW = this.ui.viewport.clientWidth;
                const vpH = this.ui.viewport.clientHeight;
                const pad = 40;
                const scaleX = (vpW - pad) / this.width;
                const scaleY = (vpH - pad) / this.height;
                let scale = Math.min(scaleX, scaleY);
                if(scale > 1) scale = 1;
                this.zoom = scale;
                this.pan.x = (vpW - this.width * scale) / 2;
                this.pan.y = (vpH - this.height * scale) / 2;
                this.updateTransform();
            },

            updateTransform() {
                this.ui.wrapper.style.transform = `translate(${this.pan.x}px, ${this.pan.y}px) scale(${this.zoom})`;
                document.getElementById('zoom-level').innerText = Math.round(this.zoom * 100) + '%';
            },

            resizeCanvas(w, h, save = true) {
                if(save) this.history.save(this.layers, this.width, this.height);
                this.width = w;
                this.height = h;
                this.ui.wrapper.style.width = w + 'px';
                this.ui.wrapper.style.height = h + 'px';
                this.ui.previewCanvas.width = w;
                this.ui.previewCanvas.height = h;

                this.layers.forEach(l => {
                    // Preserve existing content
                    const buff = document.createElement('canvas');
                    buff.width = l.canvas.width;
                    buff.height = l.canvas.height;
                    buff.getContext('2d').drawImage(l.canvas, 0, 0);
                    l.canvas.width = w;
                    l.canvas.height = h;
                    l.ctx.drawImage(buff, 0, 0);
                });
            },

            resizeCanvasFromModal() {
                const w = parseInt(document.getElementById('inp-w').value);
                const h = parseInt(document.getElementById('inp-h').value);
                if(w > 0 && h > 0) {
                    this.resizeCanvas(w, h);
                    this.ui.closeModal();
                    Utils.toast('Resized');
                }
            },

            addLayer(name, fill = null) {
                const id = Utils.uid();
                const canvas = document.createElement('canvas');
                canvas.id = id;
                canvas.width = this.width; canvas.height = this.height;
                canvas.className = 'active-canvas';
                const ctx = canvas.getContext('2d');
                if(fill) { ctx.fillStyle = fill; ctx.fillRect(0,0,this.width, this.height); }
                
                this.ui.wrapper.insertBefore(canvas, this.ui.previewCanvas);

                this.layers.unshift({
                    id, name: name || `Layer ${this.layers.length+1}`, canvas, ctx, 
                    x: 0, y: 0, visible: true, opacity: 1 
                });
                
                this.setActiveLayer(id);
                this.renderLayerDOM();
                this.renderLayerList();
                if(this.history.stack.length > 0) this.history.save(this.layers, this.width, this.height);
            },

            setActiveLayer(id) {
                this.activeLayerId = id;
                this.layers.forEach(l => l.canvas.classList.remove('active-canvas'));
                const l = this.getLayer(id);
                if(l) {
                    l.canvas.classList.add('active-canvas');
                    // Sync UI sliders
                    this.syncSidebarUI();
                }
                this.renderLayerList();
            },

            syncSidebarUI() {
                const l = this.getLayer(this.activeLayerId);
                if(!l) return;
                
                // Parse filters from style or default
                const opacity = l.opacity;
                document.getElementById('adj-opacity').value = opacity;
                document.getElementById('val-op').innerText = Math.round(opacity * 100) + '%';

                // Reset filter sliders to 0 unless they are actively applied (simplified for this demo)
                // Ideally we store numeric values in the layer object, not just the CSS string.
                // For now, we reset visual sliders to indicate "live mode" start.
                // But let's try to respect current filter if possible.
                const f = l.canvas.style.filter;
                // Simple parse (doesn't cover all cases but works for basics)
                const getVal = (reg) => {
                    const m = f.match(reg);
                    return m ? parseFloat(m[1]) : 0;
                };
                
                document.querySelector('[data-prop="brightness"]').value = getVal(/brightness\((\d+)%\)/);
                document.querySelector('[data-prop="contrast"]').value = getVal(/contrast\((\d+)%\)/);
                document.querySelector('[data-prop="saturate"]').value = getVal(/saturate\((\d+)%\)/);
                document.querySelector('[data-prop="blur"]').value = getVal(/blur\(([\d.]+)px\)/);
            },

            getLayer(id) { return this.layers.find(l => l.id === id); },

            moveLayer(fromIndex, toIndex) {
                if(fromIndex === toIndex) return;
                const item = this.layers.splice(fromIndex, 1)[0];
                this.layers.splice(toIndex, 0, item);
                this.renderLayerDOM();
                this.renderLayerList();
                this.history.save(this.layers, this.width, this.height);
            },

            deleteLayer() {
                if(this.layers.length <= 1) return Utils.toast("Cannot delete last layer");
                const idx = this.layers.findIndex(l => l.id === this.activeLayerId);
                this.layers[idx].canvas.remove();
                this.layers.splice(idx, 1);
                this.setActiveLayer(this.layers[Math.min(idx, this.layers.length-1)].id);
                this.renderLayerDOM();
                this.history.save(this.layers, this.width, this.height);
            },

            duplicateLayer() {
                const l = this.getLayer(this.activeLayerId);
                if(!l) return;
                this.addLayer(l.name + ' copy');
                const newL = this.getLayer(this.activeLayerId);
                newL.x = l.x + 20;
                newL.y = l.y + 20;
                newL.ctx.drawImage(l.canvas, 0, 0);
                newL.canvas.style.filter = l.canvas.style.filter;
                this.renderLayerDOM();
                this.history.save(this.layers, this.width, this.height);
                Utils.toast('Duplicated');
            },

            mergeDown() {
                const idx = this.layers.findIndex(l => l.id === this.activeLayerId);
                if(idx >= this.layers.length - 1) return Utils.toast("Bottom layer cannot merge down");
                const top = this.layers[idx];
                const bottom = this.layers[idx+1];
                
                bottom.ctx.globalAlpha = top.opacity;
                // Apply top filters to temp canvas before merging
                const tC = document.createElement('canvas'); tC.width=this.width; tC.height=this.height;
                const tCtx = tC.getContext('2d');
                tCtx.filter = top.canvas.style.filter;
                tCtx.drawImage(top.canvas, 0,0);
                
                bottom.ctx.drawImage(tC, top.x, top.y);
                bottom.ctx.globalAlpha = 1.0;
                
                top.canvas.remove();
                this.layers.splice(idx, 1);
                this.setActiveLayer(bottom.id);
                this.renderLayerDOM();
                this.updateLayerThumb(bottom.id);
                this.history.save(this.layers, this.width, this.height);
                Utils.toast("Merged");
            },

            transformLayer(type) {
                const l = this.getLayer(this.activeLayerId);
                if(!l) return;
                
                const temp = document.createElement('canvas');
                const ctx = temp.getContext('2d');
                const w = l.canvas.width;
                const h = l.canvas.height;

                if (type === 'flip-h') {
                    temp.width = w; temp.height = h;
                    ctx.translate(w, 0);
                    ctx.scale(-1, 1);
                    ctx.drawImage(l.canvas, 0, 0);
                } else if (type === 'flip-v') {
                    temp.width = w; temp.height = h;
                    ctx.translate(0, h);
                    ctx.scale(1, -1);
                    ctx.drawImage(l.canvas, 0, 0);
                } else if (type === 'rotate-cw') {
                    temp.width = h; temp.height = w;
                    ctx.translate(h, 0);
                    ctx.rotate(90 * Math.PI/180);
                    ctx.drawImage(l.canvas, 0, 0);
                    l.canvas.width = h; l.canvas.height = w;
                } else if (type === 'rotate-ccw') {
                    temp.width = h; temp.height = w;
                    ctx.translate(0, w);
                    ctx.rotate(-90 * Math.PI/180);
                    ctx.drawImage(l.canvas, 0, 0);
                    l.canvas.width = h; l.canvas.height = w;
                }

                l.ctx.clearRect(0,0,l.canvas.width, l.canvas.height);
                l.ctx.drawImage(temp, 0, 0);
                this.history.save(this.layers, this.width, this.height);
                this.updateLayerThumb(l.id);
                Utils.toast('Transformed');
            },

            cropCanvas(x, y, w, h) {
                if (w <= 0 || h <= 0) return;
                
                // Normalize coordinates
                let rx = x < 0 ? 0 : x;
                let ry = y < 0 ? 0 : y;
                let rw = (x + w) > this.width ? this.width - x : w;
                let rh = (y + h) > this.height ? this.height - y : h;
                
                // Constraint
                if (rx + rw > this.width) rw = this.width - rx;
                if (ry + rh > this.height) rh = this.height - ry;
                if (rx < 0) rx = 0;
                if (ry < 0) ry = 0;

                if (rw <= 0 || rh <= 0) return;

                this.history.save(this.layers, this.width, this.height);

                this.layers.forEach(l => {
                    const tempC = document.createElement('canvas');
                    tempC.width = rw;
                    tempC.height = rh;
                    const tCtx = tempC.getContext('2d');

                    // Draw the relevant portion
                    // We need to account for layer offset (l.x, l.y)
                    // The crop area (rx, ry) is in global coords.
                    // Relative to layer: relX = rx - l.x
                    tCtx.drawImage(l.canvas, rx - l.x, ry - l.y, rw, rh, 0, 0, rw, rh);

                    l.canvas.width = rw;
                    l.canvas.height = rh;
                    l.x = 0; // Reset position as content is now aligned to 0,0 of new layer
                    l.y = 0;
                    l.ctx.drawImage(tempC, 0, 0);
                });

                this.width = rw;
                this.height = rh;
                this.ui.wrapper.style.width = rw + 'px';
                this.ui.wrapper.style.height = rh + 'px';
                this.ui.previewCanvas.width = rw;
                this.ui.previewCanvas.height = rh;

                this.renderLayerDOM();
                this.centerCanvas();
                Utils.toast('Cropped');
            },

            renderLayerDOM() {
                this.layers.forEach((l, i) => {
                    l.canvas.style.zIndex = i;
                    l.canvas.style.display = l.visible ? 'block' : 'none';
                    l.canvas.style.opacity = l.opacity;
                    l.canvas.style.transform = `translate(${l.x}px, ${l.y}px)`;
                });
            },

            renderLayerList() {
                this.ui.list.innerHTML = '';
                this.layers.forEach((l, i) => {
                    const div = document.createElement('div');
                    div.className = `layer-item ${l.id === this.activeLayerId ? 'active' : ''}`;
                    div.draggable = true;
                    div.dataset.index = i;

                    const vis = l.visible ? '<i class="fas fa-eye"></i>' : '<i class="fas fa-eye-slash"></i>';
                    
                    const thumbC = document.createElement('canvas');
                    thumbC.width = 40; thumbC.height = 30;
                    thumbC.id = `thumb-${l.id}`;
                    const tCtx = thumbC.getContext('2d');
                    tCtx.fillStyle = '#eee';
                    tCtx.fillRect(0,0,40,30);
                    tCtx.drawImage(l.canvas, 0, 0, 40, 30);

                    const thumbDiv = document.createElement('div');
                    thumbDiv.className = 'layer-thumb';
                    thumbDiv.appendChild(thumbC);

                    div.innerHTML = `<div class="layer-vis">${vis}</div>`;
                    div.appendChild(thumbDiv);
                    
                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'layer-name';
                    nameDiv.innerText = l.name;
                    div.appendChild(nameDiv);

                    div.onclick = (e) => {
                        if(e.target.closest('.layer-vis')) {
                            l.visible = !l.visible;
                            this.renderLayerDOM();
                            this.renderLayerList();
                            return;
                        }
                        this.setActiveLayer(l.id);
                    };

                    div.ondragstart = (e) => {
                        e.dataTransfer.setData('text/plain', i);
                        e.dataTransfer.effectAllowed = 'move';
                        div.classList.add('dragging');
                    };
                    div.ondragend = () => div.classList.remove('dragging');
                    div.ondragover = (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; };
                    div.ondrop = (e) => {
                        e.preventDefault();
                        const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                        const toIndex = i;
                        if (fromIndex !== toIndex) this.moveLayer(fromIndex, toIndex);
                    };

                    this.ui.list.appendChild(div);
                });
            },

            updateLayerThumb(id) {
                const l = this.getLayer(id);
                const tc = document.getElementById(`thumb-${id}`);
                if(l && tc) {
                    const ctx = tc.getContext('2d');
                    ctx.clearRect(0,0, tc.width, tc.height);
                    ctx.drawImage(l.canvas, 0, 0, tc.width, tc.height);
                }
            },

            getCoords(e) {
                const rect = this.ui.wrapper.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: (clientX - rect.left) / this.zoom,
                    y: (clientY - rect.top) / this.zoom
                };
            },

            bindEvents() {
                document.querySelectorAll('.btn[data-tool]').forEach(b => {
                    b.onclick = () => {
                        document.querySelectorAll('.btn[data-tool]').forEach(x => x.classList.remove('active'));
                        b.classList.add('active');
                        this.tool = b.dataset.tool;
                        this.ui.textInput.style.display = 'none';
                        
                        if(this.tool === 'move') this.ui.viewport.setAttribute('data-cursor', 'move');
                        else if(this.tool === 'pan-layer') this.ui.viewport.setAttribute('data-cursor', 'move');
                        else if(this.tool === 'clone') this.ui.viewport.setAttribute('data-cursor', 'clone');
                        else if(this.tool === 'crop') this.ui.viewport.setAttribute('data-cursor', 'crosshair');
                        else this.ui.viewport.setAttribute('data-cursor', 'crosshair');
                        
                        if(this.tool !== 'clone') {
                            this.cloneState.active = false;
                            this.ui.sourceIndicator.style.display = 'none';
                            this.ui.cloneCursor.style.display = 'none';
                        }
                    };
                });

                const wrapper = this.ui.wrapper; 
                
                const start = (e) => {
                    if(e.button !== 0 && !e.touches) return; 
                    const l = this.getLayer(this.activeLayerId);
                    if(!l || !l.visible) return;
                    
                    const pos = this.getCoords(e);
                    const drawX = pos.x - l.x;
                    const drawY = pos.y - l.y;

                    this.isDrawing = true;
                    this.startX = pos.x; 
                    this.startY = pos.y;

                    if (this.tool === 'clone' && e.altKey) {
                        this.cloneState.active = true;
                        this.cloneState.srcX = drawX;
                        this.cloneState.srcY = drawY;
                        this.ui.sourceIndicator.style.left = (this.pan.x + pos.x * this.zoom) + 'px';
                        this.ui.sourceIndicator.style.top = (this.pan.y + pos.y * this.zoom) + 'px';
                        this.ui.sourceIndicator.style.display = 'block';
                        Utils.toast("Source Sampled");
                        this.isDrawing = false;
                        return;
                    }

                    if(['brush', 'eraser'].includes(this.tool)) {
                        l.ctx.beginPath();
                        l.ctx.moveTo(drawX, drawY);
                        l.ctx.lineCap = 'round';
                        l.ctx.lineJoin = 'round';
                        l.ctx.lineWidth = this.brushSize;
                        if(this.tool === 'eraser') l.ctx.globalCompositeOperation = 'destination-out';
                        else l.ctx.globalCompositeOperation = 'source-over';
                        l.ctx.strokeStyle = this.color;
                    } 
                    else if (this.tool === 'clone') {
                        if(!this.cloneState.active) return Utils.toast("Alt+Click to set source!");
                        this.cloneState.snapshot = document.createElement('canvas');
                        this.cloneState.snapshot.width = this.width;
                        this.cloneState.snapshot.height = this.height;
                        this.cloneState.snapshot.getContext('2d').drawImage(l.canvas, 0, 0);
                        l.ctx.globalCompositeOperation = 'source-over';
                    }
                    else if(['line','rect','circle','crop'].includes(this.tool)) {
                        this.snapshot = l.ctx.getImageData(0,0,this.width, this.height);
                    }
                    else if (this.tool === 'picker') {
                        const p = l.ctx.getImageData(Math.floor(drawX), Math.floor(drawY), 1, 1).data;
                        const hex = "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1);
                        this.setColor(hex);
                        this.isDrawing = false;
                    }
                    else if (this.tool === 'fill') {
                        this.floodFill(Math.floor(drawX), Math.floor(drawY), this.hexToRgb(this.color));
                        this.history.save(this.layers, this.width, this.height);
                        this.updateLayerThumb(this.activeLayerId);
                        this.isDrawing = false;
                    }
                    else if (this.tool === 'text') {
                        this.showTextInput(drawX, drawY, l);
                        this.isDrawing = false;
                    }
                    else if (this.tool === 'move') {
                        this.ui.viewport.classList.add('grabbing');
                    }
                };

                const move = (e) => {
                    const l = this.getLayer(this.activeLayerId);
                    if(!l) return;
                    
                    const pos = this.getCoords(e);
                    const drawX = pos.x - l.x;
                    const drawY = pos.y - l.y;

                    if (this.tool === 'clone' && this.cloneState.active && !this.isDrawing) {
                        this.ui.cloneCursor.style.display = 'block';
                        const size = this.brushSize;
                        this.ui.cloneCursor.style.width = size + 'px';
                        this.ui.cloneCursor.style.height = size + 'px';
                        this.ui.cloneCursor.style.left = (this.pan.x + pos.x * this.zoom - size/2) + 'px';
                        this.ui.cloneCursor.style.top = (this.pan.y + pos.y * this.zoom - size/2) + 'px';
                    } else {
                        this.ui.cloneCursor.style.display = 'none';
                    }

                    if(!this.isDrawing) return;

                    if (this.tool === 'move') {
                        if(e.touches) {
                           this.pan.x += (pos.x - this.startX) * this.zoom;
                           this.pan.y += (pos.y - this.startY) * this.zoom;
                           this.startX = pos.x; this.startY = pos.y;
                        } else {
                           this.pan.x += e.movementX;
                           this.pan.y += e.movementY;
                        }
                        this.updateTransform();
                    }
                    else if (this.tool === 'pan-layer') {
                        l.x += (pos.x - this.startX);
                        l.y += (pos.y - this.startY);
                        this.startX = pos.x;
                        this.startY = pos.y;
                        l.canvas.style.transform = `translate(${l.x}px, ${l.y}px)`;
                    }
                    else if(['brush', 'eraser'].includes(this.tool)) {
                        l.ctx.lineTo(drawX, drawY);
                        l.ctx.stroke();
                    }
                    else if (this.tool === 'clone') {
                        const dx = pos.x - this.startX;
                        const dy = pos.y - this.startY;
                        const srcX = this.cloneState.srcX + dx;
                        const srcY = this.cloneState.srcY + dy;
                        const r = this.brushSize / 2;

                        l.ctx.save();
                        l.ctx.beginPath();
                        l.ctx.arc(drawX, drawY, r, 0, Math.PI*2);
                        l.ctx.clip();
                        l.ctx.drawImage(this.cloneState.snapshot, 
                            srcX - r, srcY - r, r*2, r*2, 
                            drawX - r, drawY - r, r*2, r*2
                        );
                        l.ctx.restore();
                        this.startX = pos.x;
                        this.startY = pos.y;
                    }
                    else if(['line', 'rect', 'circle', 'crop'].includes(this.tool)) {
                        this.ui.previewCtx.clearRect(0,0,this.width, this.height);
                        this.ui.previewCtx.putImageData(this.snapshot, 0, 0);
                        
                        this.ui.previewCtx.beginPath();
                        this.ui.previewCtx.strokeStyle = this.tool === 'crop' ? '#000' : this.color;
                        this.ui.previewCtx.lineWidth = this.brushSize;
                        if (this.tool === 'crop') {
                            this.ui.previewCtx.setLineDash([5, 5]);
                            this.ui.previewCtx.lineWidth = 1;
                            this.ui.previewCtx.strokeStyle = '#23C9FF';
                        } else {
                            this.ui.previewCtx.setLineDash([]);
                        }

                        const startDX = this.startX - l.x;
                        const startDY = this.startY - l.y;

                        if(this.tool === 'line') {
                            this.ui.previewCtx.moveTo(startDX, startDY);
                            this.ui.previewCtx.lineTo(drawX, drawY);
                            this.ui.previewCtx.stroke();
                        } else if (this.tool === 'rect') {
                            this.ui.previewCtx.strokeRect(startDX, startDY, pos.x - this.startX, pos.y - this.startY);
                        } else if (this.tool === 'circle') {
                            const r = Math.sqrt(Math.pow(drawX - startDX, 2) + Math.pow(drawY - startDY, 2));
                            this.ui.previewCtx.arc(startDX, startDY, r, 0, 2 * Math.PI);
                            this.ui.previewCtx.stroke();
                        } else if (this.tool === 'crop') {
                            // Draw crop overlay
                            const rx = Math.min(this.startX, pos.x);
                            const ry = Math.min(this.startY, pos.y);
                            const rw = Math.abs(pos.x - this.startX);
                            const rh = Math.abs(pos.y - this.startY);
                            this.ui.previewCtx.strokeStyle = '#fff';
                            this.ui.previewCtx.setLineDash([4,4]);
                            this.ui.previewCtx.strokeRect(rx, ry, rw, rh);
                            this.ui.previewCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                            this.ui.previewCtx.fillRect(rx, ry, rw, rh);
                        }
                    }
                };

                const end = (e) => {
                    if(!this.isDrawing) return;
                    this.isDrawing = false;
                    this.ui.viewport.classList.remove('grabbing');
                    const l = this.getLayer(this.activeLayerId);

                    if(['brush', 'eraser', 'clone', 'pan-layer'].includes(this.tool)) {
                        l.ctx.globalCompositeOperation = 'source-over';
                        this.history.save(this.layers, this.width, this.height);
                        this.updateLayerThumb(this.activeLayerId);
                    }
                    else if(['line', 'rect', 'circle'].includes(this.tool)) {
                        l.ctx.drawImage(this.ui.previewCanvas, 0, 0);
                        this.ui.previewCtx.clearRect(0,0,this.width, this.height);
                        this.history.save(this.layers, this.width, this.height);
                        this.updateLayerThumb(this.activeLayerId);
                    }
                    else if (this.tool === 'crop') {
                        this.ui.previewCtx.clearRect(0,0,this.width, this.height);
                        const pos = this.getCoords(e); // Note: e might be mouseup event, coords might be slightly off, but usually consistent enough
                        // Re-calculate rect based on start and current pos
                        // Using the last 'pos' from move isn't accessible here easily, 
                        // so we rely on the user logic ending where the mouse is.
                        // For precision, we usually store endX/Y in move, but let's approximate or fetch clientXY.
                        const rect = this.ui.wrapper.getBoundingClientRect();
                        const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
                        const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
                        const endX = (clientX - rect.left) / this.zoom;
                        const endY = (clientY - rect.top) / this.zoom;

                        const rx = Math.min(this.startX, endX);
                        const ry = Math.min(this.startY, endY);
                        const rw = Math.abs(endX - this.startX);
                        const rh = Math.abs(endY - this.startY);

                        if (rw > 10 && rh > 10) {
                            this.cropCanvas(rx, ry, rw, rh);
                        }
                        // Switch back to move tool after crop
                        document.querySelector('[data-tool="move"]').click();
                    }
                };

                wrapper.addEventListener('mousedown', start);
                window.addEventListener('mousemove', move);
                window.addEventListener('mouseup', end);
                
                wrapper.addEventListener('touchstart', (e) => { if(e.touches.length===1) start(e); }, {passive: false});
                window.addEventListener('touchmove', (e) => { if(this.isDrawing && e.touches.length===1) { e.preventDefault(); move(e); } }, {passive: false});
                window.addEventListener('touchend', end);

                this.ui.viewport.addEventListener('wheel', (e) => {
                    if(e.ctrlKey) {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? 0.9 : 1.1;
                        this.zoom = Math.max(0.1, Math.min(5, this.zoom * delta));
                        this.updateTransform();
                    }
                }, {passive: false});

                // Sidebar Inputs
                document.getElementById('native-color-picker').oninput = (e) => this.setColor(e.target.value);
                document.getElementById('brush-size').oninput = (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('lbl-size').innerText = this.brushSize + 'px';
                };
                this.ui.overlay.onclick = (e) => { if(e.target === this.ui.overlay) App.ui.closeModal(); };

                // Adjustment Sliders
                document.querySelectorAll('.adj-slider').forEach(el => {
                    el.oninput = () => {
                        const l = this.getLayer(this.activeLayerId);
                        if(!l) return;
                        if(el.dataset.prop === 'opacity') {
                            l.opacity = parseFloat(el.value);
                            l.canvas.style.opacity = l.opacity;
                            document.getElementById('val-op').innerText = Math.round(l.opacity*100) + '%';
                        } else {
                            this.updateLayerFilters(l);
                        }
                    };
                });
                
                document.getElementById('btn-apply-adj').onclick = () => this.applyFilterAdjustments();
                document.getElementById('btn-reset-adj').onclick = () => this.resetAdjustments();

                // Filters
                document.querySelectorAll('.filter-btn').forEach(btn => {
                    btn.onclick = () => {
                        this.runFilter(btn.dataset.f);
                        App.ui.closeModal();
                    };
                });

                // Resize ratio checker
                document.getElementById('inp-w').oninput = () => {
                    if(document.getElementById('chk-keep-ratio').checked) {
                        const ratio = App.height / App.width;
                        document.getElementById('inp-h').value = Math.round(document.getElementById('inp-w').value * ratio);
                    }
                };
            },

            floodFill(startX, startY, fillColor) {
                const l = this.getLayer(this.activeLayerId);
                const ctx = l.ctx;
                const w = l.canvas.width;
                const h = l.canvas.height;
                const imgData = ctx.getImageData(0,0,w,h);
                const data = imgData.data;

                const startPos = (startY * w + startX) * 4;
                const startR = data[startPos], startG = data[startPos+1], startB = data[startPos+2], startA = data[startPos+3];

                if(startR === fillColor.r && startG === fillColor.g && startB === fillColor.b && startA === fillColor.a) return;

                const match = (pos) => data[pos] === startR && data[pos+1] === startG && data[pos+2] === startB && data[pos+3] === startA;
                const color = (pos) => { data[pos] = fillColor.r; data[pos+1] = fillColor.g; data[pos+2] = fillColor.b; data[pos+3] = fillColor.a; };

                const stack = [[startX, startY]];
                while(stack.length) {
                    const [x, y] = stack.pop();
                    const pos = (y * w + x) * 4;
                    if(x >= 0 && x < w && y >= 0 && y < h && match(pos)) {
                        color(pos);
                        stack.push([x+1, y], [x-1, y], [x, y+1], [x, y-1]);
                    }
                }
                ctx.putImageData(imgData, 0, 0);
            },

            showTextInput(x, y, layer) {
                const input = this.ui.textInput;
                input.style.display = 'block';
                input.style.left = (x * this.zoom + this.pan.x) + 'px';
                input.style.top = (y * this.zoom + this.pan.y) + 'px';
                input.style.fontSize = (this.brushSize * 2 * this.zoom) + 'px';
                input.style.color = this.color;
                input.value = '';
                input.focus();
                
                const finish = () => {
                    if(input.style.display === 'none') return;
                    layer.ctx.font = `bold ${this.brushSize * 2}px sans-serif`;
                    layer.ctx.fillStyle = this.color;
                    layer.ctx.fillText(input.value, x, y + (this.brushSize * 2));
                    input.style.display = 'none';
                    input.onblur = null; input.onkeydown = null;
                    this.history.save(this.layers, this.width, this.height);
                    this.updateLayerThumb(this.activeLayerId);
                };
                input.onblur = finish;
                input.onkeydown = (e) => { if(e.key === 'Enter') finish(); };
            },

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16), a: 255
                } : {r:0,g:0,b:0,a:255};
            },

            setColor(hex) {
                this.color = hex;
                document.getElementById('native-color-picker').value = hex;
                document.getElementById('hex-display').innerText = hex;
            },

            updateLayerFilters(layer) {
                const b = document.querySelector('[data-prop="brightness"]').value;
                const c = document.querySelector('[data-prop="contrast"]').value;
                const s = document.querySelector('[data-prop="saturate"]').value;
                const bl = document.querySelector('[data-prop="blur"]').value;
                layer.canvas.style.filter = `brightness(${100+parseInt(b)}%) contrast(${100+parseInt(c)}%) saturate(${100+parseInt(s)}%) blur(${bl}px)`;
            },

            resetAdjustments() {
                document.querySelectorAll('.adj-slider').forEach(el => { 
                    if(el.id !== 'adj-opacity') el.value = el.getAttribute('min'); 
                });
                const l = this.getLayer(this.activeLayerId);
                if(l) {
                    l.canvas.style.filter = 'none';
                    this.history.save(this.layers, this.width, this.height);
                }
            },

            applyFilterAdjustments() {
                const l = this.getLayer(this.activeLayerId);
                if(!l) return;
                const tC = document.createElement('canvas');
                tC.width = this.width; tC.height = this.height;
                const tCtx = tC.getContext('2d');
                tCtx.filter = l.canvas.style.filter;
                tCtx.drawImage(l.canvas, 0, 0);
                l.ctx.clearRect(0,0,this.width, this.height);
                l.ctx.drawImage(tC, 0, 0);
                l.canvas.style.filter = 'none';
                this.resetAdjustments();
                this.history.save(this.layers, this.width, this.height);
                this.updateLayerThumb(this.activeLayerId);
                Utils.toast('Applied');
            },

            runFilter(type) {
                const l = this.getLayer(this.activeLayerId);
                const w = l.canvas.width;
                const h = l.canvas.height;
                const imgData = l.ctx.getImageData(0, 0, w, h);
                const d = imgData.data;

                if(type === 'invert') {
                    for(let i=0; i<d.length; i+=4) { d[i]=255-d[i]; d[i+1]=255-d[i+1]; d[i+2]=255-d[i+2]; }
                }
                else if(type === 'grayscale') {
                    for(let i=0; i<d.length; i+=4) {
                        const v = d[i]*0.3 + d[i+1]*0.59 + d[i+2]*0.11;
                        d[i]=v; d[i+1]=v; d[i+2]=v;
                    }
                }
                else if(type === 'pixelate') {
                    const size = 10;
                    for(let y=0; y<h; y+=size) {
                        for(let x=0; x<w; x+=size) {
                            const p = (y*w+x)*4;
                            const r=d[p], g=d[p+1], b=d[p+2];
                            for(let n=0; n<size; n++){
                                for(let m=0; m<size; m++){
                                    if(x+m < w && y+n < h){
                                        const t = ((y+n)*w+(x+m))*4;
                                        d[t]=r; d[t+1]=g; d[t+2]=b;
                                    }
                                }
                            }
                        }
                    }
                }
                else if(type === 'noise') {
                    for(let i=0; i<d.length; i+=4) { const r = (0.5-Math.random())*100; d[i]+=r; d[i+1]+=r; d[i+2]+=r; }
                }
                else if (type === 'sharpen') { this.applyConvolution(l, [0,-1,0, -1,5,-1, 0,-1,0]); return; }
                else if (type === 'emboss') { this.applyConvolution(l, [-2,-1,0, -1,1,1, 0,1,2]); return; }
                else if (type === 'edge') { this.applyConvolution(l, [-1,-1,-1, -1,8,-1, -1,-1,-1]); return; }
                else if (type === 'sepia') {
                     for(let i=0; i<d.length; i+=4) {
                        const r=d[i], g=d[i+1], b=d[i+2];
                        d[i]= (r*.393)+(g*.769)+(b*.189);
                        d[i+1]= (r*.349)+(g*.686)+(b*.168);
                        d[i+2]= (r*.272)+(g*.534)+(b*.131);
                    }
                }

                l.ctx.putImageData(imgData, 0, 0);
                this.history.save(this.layers, this.width, this.height);
                this.updateLayerThumb(this.activeLayerId);
                Utils.toast('Filter Applied');
            },

            applyConvolution(layer, kernel) {
                const w = layer.canvas.width;
                const h = layer.canvas.height;
                const src = layer.ctx.getImageData(0,0,w,h);
                const dst = layer.ctx.createImageData(w,h);
                const s = src.data;
                const d = dst.data;
                const side = Math.round(Math.sqrt(kernel.length));
                const halfSide = Math.floor(side/2);

                for(let y=0; y<h; y++) {
                    for(let x=0; x<w; x++) {
                        let r=0,g=0,b=0;
                        for(let ky=0; ky<side; ky++) {
                            for(let kx=0; kx<side; kx++) {
                                const scy = y + ky - halfSide;
                                const scx = x + kx - halfSide;
                                if(scy >=0 && scy < h && scx >=0 && scx < w) {
                                    const srcOff = (scy*w+scx)*4;
                                    const wt = kernel[ky*side+kx];
                                    r += s[srcOff]*wt; g += s[srcOff+1]*wt; b += s[srcOff+2]*wt;
                                }
                            }
                        }
                        const dstOff = (y*w+x)*4;
                        d[dstOff] = r; d[dstOff+1] = g; d[dstOff+2] = b; d[dstOff+3] = s[dstOff+3];
                    }
                }
                layer.ctx.putImageData(dst, 0, 0);
            },

            exportImage() {
                const fmt = document.getElementById('exp-fmt').value;
                const name = document.getElementById('exp-name').value || 'artwork';
                const q = parseFloat(document.getElementById('exp-qual').value);

                const c = document.createElement('canvas');
                c.width = this.width; c.height = this.height;
                const ctx = c.getContext('2d');
                
                if(fmt === 'image/jpeg') {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0,0,c.width,c.height);
                }

                this.layers.slice().reverse().forEach(l => { 
                    if(l.visible) {
                        ctx.save();
                        ctx.globalAlpha = l.opacity;
                        ctx.filter = l.canvas.style.filter; // Bake CSS filters for export
                        ctx.drawImage(l.canvas, l.x, l.y);
                        ctx.restore();
                    }
                });

                const a = document.createElement('a');
                a.download = `${name}.${fmt.split('/')[1]}`;
                a.href = c.toDataURL(fmt, q);
                a.click();
                this.ui.closeModal();
            },

            initSwatches() {
                // Modern & Pastel Palette
                const colors = [
                    '#000000', '#4a4a4a', '#9b9b9b', '#ffffff',
                    '#ef476f', '#ffd166', '#06d6a0', '#118ab2', '#073b4c', // Bold
                    '#cdb4db', '#ffc8dd', '#ffafcc', '#bde0fe', '#a2d2ff', '#caf0f8', // Pastels
                    '#e0aaff', '#c77dff', '#9d4edd', '#7b2cbf', '#5a189a', '#3c096c', // Purples
                    '#ff9f1c', '#ffbf69', '#ffffff', '#cbf3f0', '#2ec4b6', '#e71d36', // Aesthetic
                    '#264653', '#2a9d8f', '#e9c46a', '#f4a261', '#e76f51', '#8d99ae'  // Earthy
                ];
                
                const c = document.getElementById('swatches');
                colors.forEach(col => {
                    this.createSwatch(col, c);
                });

                // Add Custom Button
                const addBtn = document.createElement('div');
                addBtn.className = 'swatch add-color-btn';
                addBtn.innerHTML = '<i class="fas fa-plus"></i>';
                addBtn.onclick = () => {
                    const picker = document.createElement('input');
                    picker.type = 'color';
                    picker.onchange = (e) => {
                        this.createSwatch(e.target.value, c, true);
                    };
                    picker.click();
                };
                c.appendChild(addBtn);
            },

            createSwatch(col, container, appendToEnd = false) {
                // Check duplicate
                if(Array.from(container.children).some(c => c.style.background === col)) return;
                
                const d = document.createElement('div');
                d.className = 'swatch';
                d.style.background = col;
                d.onclick = (e) => {
                    e.stopPropagation();
                    this.setColor(col);
                };
                d.oncontextmenu = (e) => {
                    e.preventDefault();
                    if(confirm('Remove this swatch?')) d.remove();
                };

                if(appendToEnd) container.insertBefore(d, container.lastElementChild);
                else container.appendChild(d);
            },

            toggleTheme() {
                const body = document.body;
                if(body.getAttribute('data-theme') === 'dark') body.removeAttribute('data-theme');
                else body.setAttribute('data-theme', 'dark');
            }
        };

        window.onload = () => {
            App.init();
            
            // Button Bindings
            document.getElementById('btn-undo').onclick = () => App.history.undo();
            document.getElementById('btn-redo').onclick = () => App.history.redo();
            document.getElementById('btn-add-layer').onclick = () => App.addLayer();
            document.getElementById('btn-del-layer').onclick = () => App.deleteLayer();
            document.getElementById('btn-merge-down').onclick = () => App.mergeDown();
            document.getElementById('btn-dup-layer').onclick = () => App.duplicateLayer();
            document.getElementById('btn-export').onclick = () => App.ui.openModal('modal-settings');

            document.getElementById('file-input').onchange = (e) => {
                const file = e.target.files[0];
                if(!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    img.onload = () => {
                        App.resizeCanvas(img.width, img.height, false);
                        App.addLayer(file.name);
                        const l = App.getLayer(App.activeLayerId);
                        l.ctx.drawImage(img, 0, 0);
                        App.centerCanvas();
                        App.history.save(App.layers, App.width, App.height);
                        App.updateLayerThumb(App.activeLayerId);
                        Utils.toast('Imported');
                    };
                    img.src = evt.target.result;
                };
                reader.readAsDataURL(file);
            };

            document.addEventListener('keydown', (e) => {
                if(e.target.tagName === 'INPUT') return;
                const k = e.key.toLowerCase();
                
                if(k === 'v') document.querySelector('[data-tool="pan-layer"]').click();
                if(k === 'b') document.querySelector('[data-tool="brush"]').click();
                if(k === 'e') document.querySelector('[data-tool="eraser"]').click();
                if(k === 'c') document.querySelector('[data-tool="clone"]').click();
                if(k === 'g') document.querySelector('[data-tool="fill"]').click();
                if(k === 'i') document.querySelector('[data-tool="picker"]').click();
                if(k === 't') document.querySelector('[data-tool="text"]').click();
                
                if(k === ']') { 
                    App.brushSize = Math.min(200, App.brushSize+5); 
                    document.getElementById('brush-size').value = App.brushSize; 
                    document.getElementById('lbl-size').innerText = App.brushSize + 'px';
                }
                if(k === '[') { 
                    App.brushSize = Math.max(1, App.brushSize-5); 
                    document.getElementById('brush-size').value = App.brushSize;
                    document.getElementById('lbl-size').innerText = App.brushSize + 'px';
                }

                if((e.ctrlKey || e.metaKey)) {
                    if(k === 'z') { e.preventDefault(); App.history.undo(); }
                    if(k === 'y') { e.preventDefault(); App.history.redo(); }
                    if(k === 's') { e.preventDefault(); App.ui.openModal('modal-settings'); }
                    if(k === 'd') { e.preventDefault(); App.duplicateLayer(); }
                }
            });
        };
    </script>
</body>
</html>
